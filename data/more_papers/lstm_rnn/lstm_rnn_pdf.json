[
    {
        "page_content": "## Alex Sherstinsky\n\nshers@alum.mit.edu\n\nhttps://www.linkedin.com/in/alexsherstinsky",
        "metadata": {
            "section_header": "Alex Sherstinsky",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## Abstract\n\nBecause of their effectiveness in broad practical applications, LSTM networks have received a wealth of coverage in scientific journals, technical blogs, and implementation guides. However, in most articles, the inference formulas for the LSTM network and its parent, RNN, are stated axiomatically, while the training formulas are omitted altogether. In addition, the technique of 'unrolling' an RNN is routinely presented without justification throughout the literature. The goal of this tutorial is to explain the essential RNN and LSTM fundamentals in a single document. Drawing from concepts in Signal Processing, we formally derive the canonical RNN formulation from differential equations. We then propose and prove a precise statement, which yields the RNN unrolling technique. We also review the difficulties with training the standard RNN and address them by transforming the RNN into the 'Vanilla LSTM' 1 network through a series of logical arguments. We provide all equations pertaining to the LSTM system together with detailed descriptions of its constituent entities. Albeit unconventional, our choice of notation and the method for presenting the LSTM system emphasizes ease of understanding. As part of the analysis, we identify new opportunities to enrich the LSTM system and incorporate these extensions into the Vanilla LSTM network, producing the most general LSTM variant to date. The target reader has already been exposed to RNNs and LSTM networks through numerous available resources and is open to an alternative pedagogical approach. A Machine Learning practitioner seeking guidance for implementing our new augmented LSTM model in software for experimentation and research will find the insights and derivations in this treatise valuable as well.",
        "metadata": {
            "section_header": "Abstract",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## I. INTRODUCTION\n\nSince the original 1997 LSTM paper [21], numerous theoretical and experimental works have been published on the subject of this type of an RNN, many of them reporting on the astounding results achieved across a wide variety of application domains where data is sequential. The impact of the LSTM network has been notable in language modeling, speech-to-text transcription, machine translation, and other applications [31]. Inspired by the impressive benchmarks reported in the literature, some readers in academic and industrial settings decide to learn about the Long Short-Term Memory network (henceforth, 'the LSTM network') in order to gauge its applicability to their own research or practical use-case. All major open source machine learning frameworks offer efficient, production-ready implementations of a number of RNN and LSTM network architectures. Naturally, some practitioners, even if new to the RNN/LSTM systems, take advantage of this access and cost-effectiveness and proceed straight to development and experimentation. Others seek to understand every aspect of the operation of this elegant and effective system in greater depth. The advantage of this lengthier path is that it affords an opportunity to build a certain degree of intuition that can prove beneficial during all phases of the process of incorporating an open source module to suit the needs of their research effort or a business application, preparing the dataset, troubleshooting, and tuning.\n\nIn a common scenario, this undertaking balloons into reading numerous papers, blog posts, and implementation guides in search of an 'A through Z' understanding of the key principles and functions of the system, only to find out that, unfortunately, most of the resources leave one or more of the key questions about the basics unanswered. For example, the Recurrent Neural Network (RNN), which is the general class of a neural network that is the predecessor to and includes the LSTM network as a special case, is routinely simply stated without precedent, and unrolling is presented without justification. Moreover, the training equations are often omitted altogether, leaving the reader puzzled and searching for more resources, while having to reconcile disparate notation used therein. Even the most oft-cited and celebrated primers to date have fallen short of providing a comprehensive introduction. The combination of descriptions and colorful diagrams alone is not actionable, if the architecture description is incomplete, or if important components and formulas are absent, or if certain core concepts are left unexplained.\n\nAs of the timeframe of this writing, a single self-contained primer that provides a clear and concise explanation of the Vanilla LSTM computational cell with well-labeled and logically composed schematics that go hand-in-hand with the formulas is still\n\n1 The nickname 'Vanilla LSTM' symbolizes this model's flexibility and generality [17].\n\nlacking. The present work is motivated by the conviction that a unifying reference, conveying the basic theory underlying the RNN and the LSTM network, will benefit the Machine Learning (ML) community.\n\nThe present article is an attempt to fill in this gap, aiming to serve as the introductory text that the future students and practitioners of RNN and LSTM network can rely upon for learning all the basics pertaining to this rich system. With the emphasis on using a consistent and meaningful notation to explain the facts and the fundamentals (while removing mystery and dispelling the myths), this backgrounder is for those inquisitive researchers and practitioners who not only want to know 'how', but also to understand 'why'.\n\nWe focus on the RNN first, because the LSTM network is a type of an RNN, and since the RNN is a simpler system, the intuition gained by analyzing the RNN applies to the LSTM network as well. Importantly, the canonical RNN equations, which we derive from differential equations, serve as the starting model that stipulates a perspicuous logical path toward ultimately arriving at the LSTM system architecture.\n\nThe reason for taking the path of deriving the canonical RNN equations from differential equations is that even though RNNs are expressed as difference equations, differential equations have been indispensable for modeling neural networks and continue making a profound impact on solving practical data processing tasks with machine learning methods. On one hand, leveraging the established mathematical theories from differential equations in the continuous-time domain has historically led to a better understanding of the evolution of the related difference equations, since the difference equations are obtained from the corresponding original differential equations through discretization of the differential operators acting on the underlying functions [20, 30, 33, 54, 57, 59, 60, 61]. On the other hand, considering the existing deep neurally-inspired architectures as the numerical methods for solving their respective differential equations aided by the recent advances in memory-efficient implementations has helped to successfully stabilize very large models at lower computational costs compared to their original versions [3, 4, 9]. Moreover, differential equations defined on the continuous time domain are a more natural fit for modeling certain real-life scenarios than the difference equations defined over the domain of evenly-discretized time intervals [6, 51].\n\nOur primary aspiration for this document, particularly for the sections devoted to the Vanilla LSTM system and its extensions, is to fulfill all of the following requirements:\n\n- 1) Intuitive - the notation and semantics of variables must be descriptive, explicitly and unambiguously mapping to their respective purposes in the system.\n- 2) Complete - the explanations and derivations must include both the inference equations ('forward pass' or 'normal operation') and the training equations ('backward pass'), and account for all components of the system.\n- 3) General - the treatment must concern the most inclusive form of the LSTM system (i.e., the 'Vanilla LSTM'), specifically including the influence of the cell's state on control nodes ('pinhole connections').\n- 4) Illustrative - the description must include a complete and clearly labeled cell diagram as well as the sequence diagram, leaving nothing to imagination or guessing (i.e., the imperative is: strive to minimize cognitive strain, do not leave anything as an 'exercise for the reader' - everything should be explained and made explicit).\n- 5) Modular - the system must be described in such a way that the LSTM cell can be readily included as part of a pluggable architecture, both horizontally ('deep sequence') and vertically ('deep representation').\n- 6) Vector notation - the equations should be expressed in the matrix and vector form; it should be straightforward to plug the equations into a matrix software library (such as numpy ) as written, instead of having to iterate through indices.\n\nIn all sources to date, one or more of the elements in the above list is not addressed 2 [5, 13, 14, 15, 16, 24, 26, 27, 32, 34, 35, 36, 40, 42, 50, 55, 56, 66, 68, 69, 78]. Hence, to serve as a comprehensive introduction, the present tutorial captures all the essential details. The practice of using a succinct vector notation and meaningful variable names as well as including the intermediate steps in formulas is designed to build intuition and make derivations easy to follow.\n\nThe rest of this document is organized as follows. Section II gives a principled background behind RNN systems. Then Section III formally arrives at RNN unrolling by proving a precise statement concerning approximating long sequences by a series of shorter, independent sub-sequences (segments). Section IV presents the RNN training mechanism based on the technique, known as 'Back Propagation Through Time', and explores the numerical difficulties, which occur when training on long sequences. To remedy these problems, Section V methodically constructs the Vanilla LSTM cell from the canonical RNN system (derived in Section II) by reasoning through the ways of making RNN more robust. Section VI provides a detailed explanation of all aspects of the Vanilla LSTM cell. Even though this section is intended to be self-contained, familiarity with the material covered in the preceding sections will be beneficial. The Augmented LSTM system, which embellishes the Vanilla LSTM system with the new computational components, identified as part of the exercise of transforming the RNN to the LSTM network, is presented in Section VII. Section VIII summarizes the covered topics and proposes future projects.",
        "metadata": {
            "section_header": "I. INTRODUCTION",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## II. THE ROOTS OF RNN\n\nIn this section, we will derive the Recurrent Neural Network (RNN) from differential equations [60, 61]. Let ⃗ s ( ) t be the value of the d -dimensional state signal vector and consider the general nonlinear first-order non-homogeneous ordinary differential equation, which describes the evolution of the state signal as a function of time, t :\n\n<!-- formula-not-decoded -->\n\nwhere ⃗ t f ( ) is a d -dimensional vector-valued function of time, t ∈ R + , and ⃗ ϕ is a constant d -dimensional vector.\n\nOne canonical form of ⃗ t f ( ) is:\n\n<!-- formula-not-decoded -->\n\nwhere ⃗ x ( ) t is the d -dimensional input signal vector and ⃗ h ⃗ s ( ( ) t , ⃗ x t ( )) is a vector-valued function of vector-valued arguments.\n\nThe resulting system,\n\n<!-- formula-not-decoded -->\n\ncomes up in many situations in physics, chemistry, biology, and engineering [65, 72].\n\nIn certain cases, one starts with s and x as entirely 'analog' quantities (i.e., functions not only of time, t , but also of another independent continuous variable, ⃗ , ξ denoting the coordinates in multi-dimensional space). Using this notation, the intensity of an input video signal displayed on a flat 2 -dimensional screen would be represented as x ⃗ , t ( ξ ) with ⃗ ξ ∈ R 2 . Sampling x ⃗ , t ( ξ ) on a uniform 2 -dimensional grid converts this signal to the representation x ⃗ i, t ( ) , where ⃗ i is now a discrete 2 -dimensional index. Finally, assembling the values of x ⃗ i, t ( ) for all permutations of the components of the index, ⃗ i , into a column vector, produces ⃗ x ( ) t as originally presented in Equation 3 above.\n\nOne special case of ⃗ t f ( ) in Equation 2 is:\n\n<!-- formula-not-decoded -->\n\nwhose constituent terms, ⃗ a ( ) t , ⃗ b ( ) t , and ⃗ c ( ) t , are d -dimensional vector-valued functions of time, t . Equation 4 is called the 'Additive Model' in Brain Dynamics research literature, because it adds the terms, possibly nonlinear, that determine the rate of change of neuronal activities, or potentials, ⃗ s ( ) t . As a cornerstone of neural network research, the abstract form of the Additive Model in Equation 4 has been particularized in many ways, including incorporating the effects of delays, imposing 'shunting' (or 'saturating') bounds on the state of the system, and other factors. Biologically motivated uses of the Additive Model span computational analyses of vision, decision making, reinforcement learning, sensory-motor control, short-term and long-term memory, and the learning of temporal order in language and speech [18]. It has also been noted that the Additive Model generalizes the Hopfield model [23], which, while rooted in biological plausibility, has been influential in physics and engineering [18, 19]. In fact, a simplified and discretized form of the Additive Model played a key role in linking the nonlinear dynamical systems governing morphogenesis, one of the fundamental aspects of developmental biology, to a generalized version of the Hopfield network [23], and applying it to an engineering problem in image processing [59, 62].\n\nConsider a saturating Additive Model in Equation 4 with the three constituent terms, ⃗ a ( ) t , ⃗ b ( ) t , and ⃗ c ( ) t , defined as follows:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhere ⃗ r ( ) t , the readout signal vector, is a warped version of the state signal vector, ⃗ s ( ) t . A popular choice for the element-wise nonlinear, saturating, and invertible 'warping' (or 'activation') function, G z ( ) , is an optionally scaled and/or shifted form of\n\nthe hyperbolic tangent. Then the resulting system, obtained by substituting Equations 5 - 8 into Equation 4 and inserting into Equation 1, becomes:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nEquation 9 is a nonlinear ordinary delay differential equation (DDE) with discrete delays. Delay is a common feature of many processes in biology, chemistry, mechanics, physics, ecology, and physiology, among others, whereby the nature of the processes dictates the use of delay equations as the only appropriate means of modeling. In engineering, time delays often arise in feedback loops involving sensors and actuators [28].\n\nHence, the time rate of change of the state signal in Equation 9 depends on three main components plus the constant ('bias') term, ⃗ ϕ . The first ('analog') component, ∑ K s -1 k =0 ⃗ a k ( ⃗ s ( t -τ s ( k ))) , is the combination of up to K s time-shifted (by the delay time constants, τ s ( k ) ) functions, ⃗ a k ( ⃗ s ( )) t , where the term 'analog' underscores the fact that each ⃗ a k ( ⃗ s ( )) t is a function of the (possibly time-shifted) state signal itself (i.e., not the readout signal, which is the warped version of the state signal). The second component, ∑ K r -1 k =0 ⃗ b k ( ⃗ r ( t -τ r ( k ))) , is the combination of up to K r time-shifted (by the delay time constants, τ r ( k ) ) functions, ⃗ b k ( ⃗ r ( )) t , of the readout signal, given by Equation 10, the warped (binary-valued in the extreme) version of the state signal. The third component, ∑ K x -1 k =0 ⃗ c k ( ⃗ x ( t -τ x ( k ))) , representing the external input, is composed of the combination of up to K x time-shifted (by the delay time constants, τ x ( k ) ) functions, ⃗ c k ( ⃗ x ( )) t , of the input signal 3 .\n\nThe rationale behind choosing a form of the hyperbolic tangent as the warping function is that the hyperbolic tangent possesses certain useful properties. On one hand, it is monotonic and negative-symmetric with a quasi-linear region, whose slope can be regulated [38]. On the other hand, it is bipolarly-saturating (i.e., bounded at both the negative and the positive limits of its domain). The quasi-linear mode aides in the design of the system's parameters and in interpreting its behavior in the 'small signal' regime (i.e., when ∥ ⃗ s ( ) t ∥ ≪ 1) . The bipolarly-saturating ('squashing') aspect, along with the proper design of the internal parameters of the functions ⃗ a k ( ⃗ s ( )) t and ⃗ b k ( ⃗ r ( )) t , helps to keep the state of the system (and, hence, its output) bounded. The dynamic range of the state signals is generally unrestricted, but the readout signals are guaranteed to be bounded, while still carrying the state information with low distortion in the quasi-linear mode of the warping function (the 'small signal' regime). If the system, described by Equation 9 and Equation 10, is stable, then the state signals are bounded as well [64].\n\nThe time delay terms on the right hand side of Equation 9 comprise the 'memory' aspects of the system. They enable the quantity holding the instantaneous time rate of change of the state signal, d⃗ s ( ) t dt , to incorporate contributions from the state, the readout, and the input signal values, measured at different points in time, relative to the current time, t . Qualitatively, these temporal elements enrich the expressive power of the model by capturing causal and/or contextual information.\n\nIn neural networks, the time delay is an intrinsic part of the system and also one of the key factors that determines the dynamics 4 . Much of the pioneering research in recurrent networks during the 1970s and the 1980s was founded on the premise that neuron processes and interactions could be expressed as systems of coupled DDEs [18, 23]. Far from the actual operation of the human brain, based on what was already known at the time, these 'neurally inspired' mathematical models have been shown to exhibit sufficiently interesting emerging behaviors for both, advancing the knowledge and solving real-world problems in various practical applications. While the major thrust of research efforts was concerned primarily with continuoustime networks, it was well understood that the learning procedures could be readily adapted to discrete systems, obtained from the original differential equations through sampling. We will also follow the path of sampling and discretization for deriving the RNN equations [60]. Over the span of these two decades, pivotal and lasting contributions were made in the area of training networks containing interneurons 5 with 'Error Back Propagation' (or 'Back Propagation of Error', or 'Back Propagation' for short), a special case of a more general error gradient computation procedure. To accommodate recurrent networks, both continuous-time and discrete-time versions of 'Back Propagation Through Time' have been developed on the foundation of Back Propagation and used to train the weights and time delays of these networks to perform a wide variety of tasks [11, 25, 45, 46, 47, 48]. We will rely on Back Propagation Through Time for training the systems analyzed in this paper.\n\nThe contribution of each term on the right hand side of Equation 9 to the overall system is qualitatively different from that of the others. The functions, ⃗ a k ( ⃗ s ( t -τ s ( k ))) , of the ('analog') state signal in the first term have a strong effect on the stability of the system, while the functions, ⃗ b k ( ⃗ r ( t -τ r ( k ))) , of the (bounded) readout signal in the second term capture most of the interactions that shape the system's long-term behavior. If warranted by the modeling requirements of the biological or physical system and/or of the specific datasets and use-cases in an engineering setting, the explicit inclusion of non-zero delay time constants in these terms provides the necessary weighting flexibility in the temporal domain (e.g., to account for delayed neural interactions) [10]. Thus, the parameters, K s , K r , and K x representing the counts of the functions, ⃗ a k ( ⃗ s ( t -τ s ( k ))) , ⃗ b k ( ⃗ r ( t -τ r ( k ))) , and ⃗ c k ( ⃗ x ( t -τ x ( k ))) , respectively (and the counts of the associated delay time constants, τ s ( k ) , τ r ( k ) , and τ x ( k ) , respectively, of these functions), in the system equations are chosen (or estimated by an iterative procedure) accordingly.\n\nSuppose that ⃗ a k ( ⃗ s ( t -τ s ( k ))) , ⃗ b k ( ⃗ r ( t -τ r ( k ))) , and ⃗ c k ( ⃗ x ( t -τ x ( k ))) are linear functions of ⃗ s , ⃗ r , and ⃗ x , respectively. Then Equation 9 becomes a nonlinear DDE with linear (matrix-valued) coefficients:\n\n<!-- formula-not-decoded -->\n\nFurthermore, if the matrices, A k , B k , and C k , are circulant (or block circulant), then the matrix-vector multiplication terms in Equation 11 can be expressed as convolutions in the space of the elements of ⃗ s , ⃗ r , ⃗ x , and ⃗ ϕ , each indexed by ⃗ i :\n\n<!-- formula-not-decoded -->\n\nThe index, ⃗ i , is 1 -dimensional if the matrices, A k , B k , and C k , are circulant and multi-dimensional if they are block circulant 6 .\n\nThe summations of time delayed terms in Equation 12 represent convolutions in the time domain with finite-sized kernels, consisting of the spatial convolutions a k ( ) ⃗ i ∗ s ⃗ ( ) i , b k ( ) ⃗ i ∗ r ⃗ ( ) i , and c k ( ) ⃗ i ∗ x ⃗ i ( ) as the coefficients for the three temporal components, respectively. In fact, if the entire data set (e.g., the input data set, ⃗ x ( ) t ) is available a priori for all time ahead of the application of Equation 12, then some of the corresponding time delays (e.g., τ x ( k ) ) can be negative, thereby allowing the incorporation of 'future' information for computing the state of the system at the present time, t . This will become relevant further down in the analysis.\n\nBefore proceeding, it is interesting to note that earlier studies linked the nonlinear dynamical system, formalized in Equation 9 (with K s = K r = K x = 1 and all τ s , τ r , and τ x set to zero), to the generalization of a type of neural networks 7 . Specifically the variant, in which the functions ⃗ a k ( ⃗ s ( )) t , ⃗ b k ( ⃗ r ( )) t , and ⃗ c k ( ⃗ x ( )) t are linear operators as in Equation 11 (with K s = K r = K x = 1 and all τ s , τ r , and τ x set to zero) was shown to include the Continuous Hopfield Network [23] as a special case. Its close relative, in which these operators are further restricted to be convolutional as in Equation 12 (again, with K s = K r = K x = 1 and all τ s , τ r , and τ x set to zero), was shown to include the Cellular Neural Network [7, 8] as a special case [59, 62, 64].\n\nApplying the simplifications:\n\n<!-- formula-not-decoded -->\n\n(some of which will be later relaxed) to Equation 11 turns it into:\n\n<!-- formula-not-decoded -->\n\nEquation 11, Equation 12, and, hence, Equation 14 are nonlinear first-order non-homogeneous DDEs. A standard numerical technique for evaluating these equations, or, in fact, any embodiments of Equation 1, is to discretize them in time and compute the values of the input signals and the state signals at each time sample up to the required total duration, thereby performing numerical integration.\n\nDenoting the duration of the sampling time step as △ T and the index of the time sample as n in the application of the backward Euler discretization rule 8 to Equation 14 yields : 9\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nA⃗ s ( t + △ T ) + B⃗ r ( t + △ T -τ 0 ) + C⃗ x ( t + △ T ) + ⃗ ϕ = A⃗ s ( n △ T + △ T ) + B⃗ r ( n △ T + △ T -τ 0 ) + C⃗ x ( n △ T + △ T ) + ⃗ ϕ\n\n(18)\n\n<!-- formula-not-decoded -->\n\n(19)\n\nNow set the delay, τ 0 , equal to the single time step. This can be interpreted as storing the value of the readout signal into memory at every time step to be used in the above equations at the next time step. After a single use, the memory storage can be overwritten with the updated value of the readout signal to be used at the next time step, and so forth 10 . Thus, setting τ 0 = △ T and replacing the approximation sign with an equal sign for convenience in Equation 19 gives:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nAfter performing the discretization, all measurements of time in Equation 22 become integral multiples of the sampling time step, △ T . Now, △ T can be dropped from the arguments, which leaves the time axis dimensionless. Hence, all the signals are transformed into sequences, whose domain is the discrete index, n , and Equation 14 turns into a nonlinear first-order non-homogeneous difference equation [1]:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nDefining:\n\n<!-- formula-not-decoded -->\n\nand multiplying both sides of Equation 24 by W s leads to:\n\n<!-- formula-not-decoded -->\n\nwhich after shifting the index, n , forward by 1 step becomes:\n\n<!-- formula-not-decoded -->\n\n8 The backward Euler method is a stable discretization rule used for solving ordinary differential equations numerically [70]. A simple way to express this rule is to substitute the forward finite difference formula into the definition of the derivative, relax the requirement △ T → 0 , and evaluate the function on the right hand side (i.e., the quantity that the derivative is equal to) at time, t + △ T .\n\n9 It is straightforward to extend the application of the discretization rule to the full Equation 11, containing any or all the time delay terms and their corresponding matrix coefficients, without the above simplifications. So there is no loss of generality.\n\n10 Again, the additional terms, containing similarly combined time delayed input signals (as will be shown to be beneficial later in this paper) and state signals, can be included in the discretization, relaxing the above simplifications as needed to suit the requirements of the particular problem at hand.\n\nDefining two additional weight matrices and a bias vector,\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\ntransforms the above system into the canonical Recurrent Neural Network (RNN) form:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nFig. 1. Canonical RNN cell. The bias parameters, ⃗ , θ s have been omitted from the figure for brevity. It can be assumed to be included without the loss of generality by appending an additional element, always set to 1 , to the input signal vector, ⃗ x [ n ] , and increasing the row dimensions of W x by 1 .\n\n<!-- image -->\n\nThe RNN formulation in Equation 30, diagrammed in Figure 1, will be later logically evolved into the LSTM system. Before that, it is beneficial to introduce the process of 'unrolling' 11 and the notion of a 'cell' of an RNN. These concepts will be simpler to describe using the standard RNN definition, which is derived next from Equation 30 based on stability arguments.\n\nFor the system in Equation 30 to be stable, every eigenvalue of ˆ W = W s + W r must lie within the complex-valued unit circle [1, 65]. Since there is considerable flexibility in the choice of the elements of A and B to satisfy this requirement, setting △ T = 1 for simplicity is acceptable. As another simplification, let A be a diagonal matrix with large negative entries (i.e., a ii ≪ 0 ) on its main diagonal (thereby practically guaranteeing the stability of Equation 14). Then, from Equation 25, W s ≈ -A -1 will be a diagonal matrix with small positive entries, 1 | a ii | , on its main diagonal, which means that the explicit effect of the state signal's value from memory, ⃗ s [ n -1] , on the system's trajectory will be negligible (the implicit effect through ⃗ r [ n -1] will still be present as long as ∥ W r ∥ &gt; 0 ). Thus, ignoring the first term in Equation 30, reduces it to the standard RNN definition:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nFrom Equation 32, now only the matrix ˆ W ≈ W r ≈ -A -1 B is responsible for the stability of the RNN. Consider the best case scenario, where B is a diagonal matrix ( B = Λ B ). With this simplification, the essential matrix for analyzing the stability of Equation 32 becomes ˜ W = -A -1 Λ B , where Λ B is the diagonal matrix (i.e., consisting of only the eigenvalues of B , with the individual eigenvalues, λ i , on the main diagonal of Λ B ). Since both A and Λ B are diagonal, ˜ W is a diagonal matrix with the entries µ i = λ i | a ii | on its main diagonal. These quantities become the eigenvalues of the overall RNN system in Equation 32 in the 'small signal regime' ( ∥ ⃗ s [ n ] ∥ ≪ 1) , each adding the mode of ( µ i ) n , multiplied by its corresponding initial condition, to the trajectory of ⃗ s [ n ] . A necessary and sufficient condition for stability is that 0 &lt; µ i &lt; 1 , meaning that every eigenvalue, λ i , of B must satisfy the condition 0 &lt; λ i &lt; a | ii | . If any µ i and λ i fail to satisfy this condition, the system will be unstable, causing the elements of ⃗ r [ n ] to either oscillate or saturate (i.e., enter the flat regions of the warping nonlinearity) at some value of the index, n .\n\nAn alternative to choosing the specific convenient form of A in Equation 25 would be to (somewhat arbitrarily) treat W s , W r , W x , and ⃗ θ s in Equation 30 as mutually independent parameters and then set W s = 0 to obtain the standard RNN definition (as in Equation 32). In this case, the above stability analysis still applies. In particular, the eigenvalues, µ i , of W r are subject to the same requirement, 0 &lt; µ i &lt; 1 , as a necessary and sufficient condition for stability.\n\nStability considerations will be later revisited in order to justify the need to evolve the RNN to a more complex system, namely, the LSTM network.\n\nWe have shown that the RNN, as expressed by Equation 30 (in the canonical form) or by Equation 32 (in the standard form), essentially implements the backward Euler numerical integration method for the ordinary DDE in Equation 14. This 'forward' direction of starting in the continuous-time domain (differential equation) and ending in the discrete-index domain (difference equation) implies that the original phenomenon being modeled is assumed to be fundamentally analog in nature, and that it is modeled in the discrete domain as an approximation for the purpose of realization. For example, the source signal could be the audio portion of a lecture, recorded on an analog tape (or on digital media as a finely quantized waveform and saved in an audio file). The original recording thus contains the spoken words as well as the intonation, various emphases, and other vocal modulations that communicate the content in the speaker's individual way as expressed through voice. The samples generated by a hypothetical discretization of this phenomenon, governed in this model by Equation 14, could be captured as the textual transcript of the speech, saved in a document containing only the words uttered by the speaker, but ignoring all the intonation, emotion, and other analogous nuances. In this scenario, it is the sequence of words in the transcript of the lecture that the RNN will be employed to reproduce, not the actual audio recording of the speech. The key subtle point in this scenario is that applying the RNN as a model implies that the underlying phenomenon is governed by Equation 14, whereby the role of the RNN is that of implementing the computational method for solving this DDE using the backward Euler discretization rule, under the restriction that the sampling time step, △ T , is equal to the delay, τ 0 . In contrast, the 'reverse' direction would be a more appropriate model in situations where the discrete signal is the natural starting domain, because the phenomenon originates as a sequence of samples. For example, a written essay originates as a sequence of words and punctuation, saved in a document. One can conjure up an analog rendition of this essay as being read by a narrator, giving life to the words and passages with intonation, pauses, and other expressions not present in the original text of the essay. While the starting point depends on how the original source of data is generated, both the continuous ('forward') and the discrete ('reverse') representations can serve as tools for gaining insight into the advantages and the limitations of the models under consideration.",
        "metadata": {
            "section_header": "II. THE ROOTS OF RNN",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## III. RNN UNFOLDING/UNROLLING\n\nIt is convenient to use the term 'cell' when referring to Equation 30 and Equation 32 in the uninitialized state. In other words, the sequence has been defined by these equations, but its terms not yet computed. Then the cell can be said to be 'unfolded' or 'unrolled' by specifying the initial conditions on the state signal, ⃗ s [ n ] , and numerically evaluating Equation 30 or Equation 32 for a finite range of discrete steps, indexed by n . This process is illustrated in Figure 2.\n\nFig. 2. Sequence of steps generated by unrolling an RNN cell.\n\n<!-- image -->\n\nBoth Equation 30 and Equation 32 are recursive in the state signal, ⃗ s [ n ] . Hence, due to the repeated application of the recurrence relation as part of the unrolling, the state signal, ⃗ s [ n ] , at some value of the index, n , no matter how large, encompasses the contributions of the state signal, ⃗ s [ k ] , and the input signal, ⃗ x [ k ] , for all indices, k &lt; n , ending at k = 0 , the start of the sequence [11, 25]. Because of this attribute, the RNN belongs to the category of the 'Infinite Impulse Response' (IIR) systems.\n\nDefine the vector-valued unit step function as:\n\n<!-- formula-not-decoded -->\n\nwhere ⃗ 0 and ⃗ 1 denote vectors, all of whose elements are equal to 0 and to 1 , respectively. Then the vector-valued unit sample function, ⃗ n δ [ ] , is defined by being ⃗ 1 at n = 0 , and ⃗ 0 otherwise. In terms of ⃗ u [ n ] ,\n\n<!-- formula-not-decoded -->\n\nThese functions are depicted in Figure 3.\n\nFig. 3. The unit step and the unit sample ('impulse') functions plotted (in one data dimension) against the discrete index, n .\n\n<!-- image -->\n\nExample 1. The IIR (i.e., unending) nature of the sequences, governed by these equations, can be readily demonstrated by letting ⃗ s [ -1] = 0 ⃗ be the initial condition, setting ⃗ x [ n ] = ⃗ n δ [ ] , the unit sample stimulus (i.e., the 'impulse'), and computing the response, ⃗ s [ n ] , to this 'impulse' for several values of the index, n , in order to try to recognize a pattern. In the case of Equation 32 with ⃗ θ s = 0 ⃗ , the sequence of ⃗ s [ n ] values will be:\n\n<!-- formula-not-decoded -->\n\nand so forth. Evidently, it is defined for every positive n , even when the input is only a single impulse at n = 0 .\n\nIn practice, it is desirable to approximate a sequence with an infinite support (IIR), such as Equation 30 or Equation 32, by a 'Finite Impulse Response' (FIR) sequence. The rationale is that FIR systems have certain advantages over IIR systems. One advantage is guaranteed stability - FIR systems are intrinsically stable. Another advantage is that FIR systems are realizable with finite computational resources. An FIR system will take a finite number of steps to compute the output from the input and will require a finite number of memory locations for storing intermediate results and various coefficients. Moreover, the computational complexity and storage requirements of an FIR system are known at design time.\n\nDenote the sequence of the 'ground truth' output values by ⃗ v [ n ] for any value of the index, n , and let N be the length of the sequence, ⃗ v [ n ] , where N can be an arbitrarily large integer (e.g., the total number of samples in the training set, or the number of inputs presented to the system for inference over the lifetime of the system, etc.). Suppose that ⃗ v [ n ] ⌋ 0 ≤ ≤ n N -1 is subdivided into M non-overlapping varying-length segments with K m samples per segment, where every K m is finite, and K m ≤ N . It can be assumed that M is an integer with M ≥ 1 (if needed, the RNN system in Equation 32 can be 'padded' with extra ⃗ x [ n ] = 0 ⃗ input terms for this to hold).\n\nFormally, let ⃗ v [ n ] ⌋ 0 ≤ ≤ n N -1 be the sequence of the ground truth output values for any value of the index, n , and assume that there exists a partitioning of ⃗ v [ n ] ⌋ 0 ≤ ≤ n N -1 into M non-overlapping segments, ⃗ v m [ n ] , 0 ≤ m ≤ M -1 :\n\n<!-- formula-not-decoded -->\n\nFor subdividing a sequence into M non-overlapping segments, consider a vector-valued 'rectangular' window function, ⃗ w 0 [ n ] , which has the value of ⃗ 1 within the window 0 ≤ n ≤ K 0 -1 and ⃗ 0 otherwise. In terms of the vector-valued unit step function, ⃗ u [ n ] , ⃗ w 0 [ n ] is defined as:\n\n<!-- formula-not-decoded -->\n\nCombining Equation 35 with Equation 38 provides an alternative ('sampling') definition of ⃗ w 0 [ n ] :\n\n<!-- formula-not-decoded -->\n\nThen from Equation 39, the RNN sequence can be sampled in its entirety by the full N -samples-long window:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nl\n\n=\n\nk\n\n-\n\nj\n\n(\n\nm\n\n)\n\nk\n\n= (\n\nl\n\n-→\n\nk\n\nj\n\nm\n\n) +\n\nl\n\nwhere:\n\nand:\n\nUnder the change of indices,\n\nEquation 43 becomes:\n\n<!-- formula-not-decoded -->\n\nEquation 44 indicates that each ⃗ w m [ n ] is a rectangular window, whose size is K m samples. Hence, 'extracting' a K m -samples-long segment with the index, m , from the overall ground truth output sequence, ⃗ v [ n ] ⌋ 0 ≤ ≤ n N -1 , amounts to multiplying this sequence by ⃗ w m [ n ] :\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhere j ( m ) is given by Equation 42. According to Equation 46, the segment-level ground truth output subsequence, ⃗ v m [ n ] ⌋ 0 ≤ ≤ n N -1 , in Equation 45 will have non-zero values for the given value of the segment index, m , where 0 ≤ m ≤ M -1 , only when the index, n , is in the range j ( m ) ≤ n ≤ j ( m ) + K m -1 . This is in agreement with Equation 37.\n\nDefine Q ⟨ ( ⃗ r [ n ] ⟩ ) as an invertible map that transforms an ensemble of the readout signals of the RNN system, ⟨ ⃗ r [ n ] ⟩ , into an ensemble of observable output signals, ⟨ ⃗ y [ n ] ⟩ , for 0 ≤ n ≤ N -1 :\n\n<!-- formula-not-decoded -->\n\nIn addition, define L as an 'objective function' (or 'merit function' [71]) that measures the cost of the observable output of the system deviating from the desired ground truth output values, given the input data, supplied over the entire range of the values of the index, n :\n\n<!-- formula-not-decoded -->\n\nwhere ⟨ ⃗ y [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 denotes the ensemble of all N members of the sequence of the observable output variables, ⃗ y [ n ] , and ⟨ ⃗ v [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 denotes the ensemble of all N members of the sequence of the ground truth output values, ⃗ v [ n ] .\n\nAs shorthand, combine all parameters of the standard RNN system in Equation 32 under one symbol, Θ :\n\n<!-- formula-not-decoded -->\n\nProposition 1. Given the standard RNN system in Equation 32 parameterized by Θ , defined in Equation 49, assume that there exists a value of Θ , at which the objective function, L , defined in Equation 48 for an N -samples-long sequence, is close to an optimum as measured by some acceptable bound. Further, assume that there exist non-zero finite constants, M and K m , such that K m &lt; N , where 0 ≤ m ≤ M -1 , and that the ground truth output sequence, ⃗ v [ n ] ⌋ 0 ≤ ≤ n N -1 , can be partitioned into mutually independent segment-level ground truth output subsequences, ⃗ v m [ n ] ⌋ 0 ≤ ≤ n N -1 , for different values of the segment index, m , as specified in Equation 46. Then a single, reusable RNN cell, unrolled for an adjustable number of steps, K m , is computationally sufficient for seeking Θ that optimizes L over the training set and for inferring outputs from unseen inputs.\n\nProof. The objective function in Equation 48 computes the error in the system's performance during training, validation, and testing phases as well as tracks its generalization metrics on the actual application data during the inference phase. By the assumption, L can be optimized. This implies that when L is acceptably close to an optimum, the observable output ensemble from the RNN system approximates the ground truth output ensemble within a commensurately acceptable tolerance bound:\n\n<!-- formula-not-decoded -->\n\nSegmenting the RNN system's output sequence by the same procedure as was used in Equation 45 to segment the ground truth output sequence gives:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhere j ( m ) is given by Equation 42. According to Equation 52, the segment-level output subsequence, ⃗ y m [ n ] ⌋ 0 ≤ ≤ n N -1 , in Equation 51 will have non-zero values for the given value of the segment index, m , where 0 ≤ m ≤ M -1 , only when the index, n , is in the range j ( m ) ≤ n ≤ j ( m ) + K m -1 .\n\nBy the assumption that the segment-level ensembles of the ground truth output subsequences are mutually independent, the objective function in Equation 48 is separable and can be expressed as a set of M independent segment-level components, {L m ( ⟨ ⃗ y m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 , ⟨ ⃗ v m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 ) } , 0 ≤ m ≤ M -1 , combined by a suitable function, C :\n\n<!-- formula-not-decoded -->\n\nThen by Equation 50 and Equation 53,\n\n<!-- formula-not-decoded -->\n\nfor all values of the segment index, m , where 0 ≤ m ≤ M -1 . In other words, the tracking of the ground truth output by the observable output of the RNN system at the entire N -sample ensemble level must hold at the K m -samples-long segment level, too, for all segments.\n\nSince Q ⟨ ( ⃗ r [ n ] ⟩ ) is invertible,\n\n<!-- formula-not-decoded -->\n\nand since the warping function, G z ( ) , in Equation 33 is invertible, then for any value of the sample index, n ,\n\n<!-- formula-not-decoded -->\n\n̸\n\nAccording to Equation 50, Equation 55, and Equation 56, ⟨ ⃗ y m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 , ⟨ ⃗ r m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 , and ⃗ s m [ n ] ⌋ 0 ≤ ≤ n N -1 are all functions of random variables. Let ⟨ ⃗ v m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 and ⟨ ⃗ v l [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 be the ground truth output subsequence ensembles, belonging to any two segments, whose indices are m and l , respectively, with m = l . By the assumption, ⟨ ⃗ v m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 and ⟨ ⃗ v l [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 are independent random variables. Because the functions of independent variables are also independent, it follows that at the segment level the observable output signal subsequence ensembles, ⟨ ⃗ y m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 and ⟨ ⃗ y l [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 , are independent, the readout signal subsequence ensembles, ⟨ ⃗ r m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 and ⟨ ⃗ r l [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 , are independent, and the state signal subsequences, ⃗ s m [ n ] ⌋ 0 ≤ ≤ n N -1 and ⃗ s l [ n ] ⌋ 0 ≤ ≤ n N -1 , are independent.\n\nThe mutual independence of the state signal subsequences, ⃗ s m [ n ] ⌋ 0 ≤ ≤ n N -1 , for different values of the segment index, m , places a restriction on the initial conditions of these subsequences. Specifically, the initial condition for the state signal subsequence of one segment cannot be a function of samples belonging to either the state signal subsequence or the input signal subsequence of another segment for any value of the index, n .\n\nPerforming the element-wise multiplication of the input sequence, ⃗ x [ n ] ⌋ 0 ≤ ≤ n N -1 , by the sampling window, ⃗ w m [ n ] , extracts a segment-level input sequence with the index, m :\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhere j ( m ) is given by Equation 42. According to Equation 58, the segment-level input subsequence, ⃗ x m [ n ] ⌋ 0 ≤ ≤ n N -1 , in Equation 57 will have non-zero values for the given value of the segment index, m , where 0 ≤ m ≤ M -1 , only when the index, n , is in the range j ( m ) ≤ n ≤ j ( m ) + K m -1 .\n\nDue to recursion, the members of the state signal sequence, ⃗ s m [ n ] ⌋ 0 ≤ ≤ n N -1 , in an RNN system can in general depend on the entire input signal sequence assembly. However, since under the present assumptions the segment-level state signal subsequences, ⃗ s m [ n ] ⌋ 0 ≤ ≤ n N -1 and ⃗ s l [ n ] ⌋ 0 ≤ ≤ n N -1 , belonging to different segments, are independent, the dependency of ⃗ s m [ n ] ⌋ 0 ≤ ≤ n N -1 on the input signal must be limited to the same segment-level subsequence (i.e., with segment index, m ). If we define F ( ⟨ ⃗ x m [ n ] ⟩ ⌋ j ( m ) ≤ ≤ n j ( m )+ K m -1 ) as a map that transforms the segment-level input signal subsequence assembly, ⟨ ⃗ x m [ n ] ⟩ ⌋ 0 ≤ ≤ n N -1 , into the segment-level state signal subsequence assembly, ⟨ ⃗ s m [ n ] ⟩ ⌋ j ( m ) ≤ ≤ n j ( m )+ K m -1 , then the standard RNN system definition in Equation 32 at the K m -samples-long segment level can be expressed as:\n\n<!-- formula-not-decoded -->\n\n̸\n\nHence, for any 0 ≤ m,l ≤ M -1 with m = l , the restriction,\n\n<!-- formula-not-decoded -->\n\nmust be enforced in order to satisfy the independence of the segment-level state signal subsequences. The only way to achieve this is to set ⃗ s m [ n = ( j m ) -1] to a random vector or to ⃗ 0 . The latter choice is adopted here for simplicity.\n\nThus, substituting Equation 58 and Equation 60 into Equation 32 yields the RNN system equations for an individual segment:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n⃗\n\n[\n\nn\n\n= ( j\n\nm\n\n)\n\n-\n\n1] = 0\n\n⃗ s\n\nm\n\nMaking the index substitution,\n\n(63)\n\n<!-- formula-not-decoded -->\n\nn\n\n-→\n\nn\n\n+ (\n\nj\n\nm\n\n)\n\nshifts the segment-level subsequences, ⃗ r m [ n ] ⌋ 0 ≤ ≤ n N -1 , ⃗ s m [ n ] ⌋ 0 ≤ ≤ n N -1 , and ⃗ x m [ n ] ⌋ 0 ≤ ≤ n N -1 , by -j ( m ) samples:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n⃗\n\n˜\n\ns\n\nm\n\n[\n\nn\n\n]\n\n≡\n\n⃗ s\n\nm\n\n{\n\n=\n\n[\n\nn\n\n+ (\n\nW ⃗ r\n\n⃗ ,\n\n0\n\notherwise\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nr\n\nm\n\nj\n\nm\n\n)]\n\n⌋\n\n[\n\nn\n\n+ (\n\nj\n\nm\n\n)\n\n-\n\n1] +\n\nW ⃗ x\n\n0\n\n≤ ≤\n\nn\n\nN\n\n-\n\n1\n\nx\n\nm\n\n[\n\nn\n\n+ (\n\nj\n\nm\n\n)] +\n\n⃗ ,\n\nθ\n\ns\n\nj\n\n(\n\nm\n\n)\n\n≤\n\nn\n\n+ (\n\nj\n\nm\n\n)\n\n≤\n\nj\n\n(\n\nm\n\n) +\n\nK\n\nm\n\n-\n\n1\n\nSimplified, these equations reduce to the form of the standard RNN system, unrolled for K m steps, for any segment with the index, m , where 0 ≤ m ≤ M -1 :\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nIt follows that the shifted segment-level state signal subsequences, ⃗ ˜ s m [ n ] ⌋ 0 ≤ ≤ n K m -1 , for different values of the segment index, m , where 0 ≤ m ≤ M -1 , are mutually independent. In addition, from Equation 71, Equation 70, and Equation 72, the non-zero values of the resulting sequences, ⃗ ˜ r m [ n ] ⌋ 0 ≤ ≤ n K m -1 , ⃗ ˜ s m [ n ] ⌋ 0 ≤ ≤ n K m -1 , and ⃗ ˜ x m [ n ] ⌋ 0 ≤ ≤ n K m -1 , are confined to 0 ≤ n ≤ K m -1 for any value of the segment index, m , where 0 ≤ m ≤ M -1 .\n\nAs the sample index, n, traverses the segment-level range, 0 ≤ n ≤ K m -1 , for every segment with the index, m , where 0 ≤ m ≤ M -1 , the input subsequence, ⃗ ˜ x m [ n ] , takes on all the available values of the input sequence, ⃗ x [ n ] , segment by segment. Similarly to the original RNN system in Equation 32, the input signal, ⃗ ˜ x m [ n ] (the external driving force), is the only independent variable of the RNN system, unrolled for K m steps, in Equation 70. Together with the mutual independence of ⃗ ˜ s m [ n ] ⌋ 0 ≤ ≤ n K m -1 for different segments, this makes the computations of the RNN system, unrolled for K m steps, generic for all segments. The only signal that retains the dependence on the segment index, m , is the input. Dropping the segment subscript, m , from the variables representing the state signal and the readout signal results in the following prototype formulation of the RNN system, unrolled for K m steps:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhere j ( m ) is given by Equation 42.\n\nThe same prototype variable-length RNN computation, unrolled for K m steps, can process all segments, one at a time. After initializing the segment's state signal using Equation 73 and selecting the input samples for the segment using Equation 76, Equation 74 and Equation 75 are evaluated for K m steps, 0 ≤ n ≤ K m -1 . This procedure can then be applied to the next segment using the same computational module, and then to the next segment, and so on, until the inputs comprising all M segments have been processed. Moreover, the mutual independence of the segments facilitates parallelism, whereby the computation of ⃗ ˜ s m [ n ] , ⃗ ˜ r m [ n ] , and ⃗ y m [ n ] for 0 ≤ n ≤ K m -1 can be carried out for all M segments concurrently.\n\nRemark 1 . Proposition 1 and its proof do not formally address advanced RNN architectures, such as Gated Recurrent Unit (GRU), Attention Networks, and complex models comprised of multiple LSTM networks.\n\nRemark 2 . While the segment-level state signal subsequences, ⃗ ˜ s m [ n ] ⌋ 0 ≤ ≤ n K m -1 , are independent, there is no independence requirement on the input signal subsequences, ⃗ ˜ x m [ n ] , belonging to the different segments. It has been shown that dependencies in the input signal can be de-correlated by appropriately trained hidden layer weights, W x , thus maintaining the independence of ⃗ ˜ s m [ n ] ⌋ 0 ≤ ≤ n K m -1 [57, 63].\n\nRemark 3 . It is important to emphasize that no IIR-to-FIR conversion method is optimal in the absolute sense. Finding an optimal FIR approximation to an IIR system can only be done with respect to a certain measure of fidelity and performance. In practice, one must settle for an approximation to the ideal form of the output signal. The success of an approximation technique depends on the degree to which the resulting FIR system can be adapted to fit the specific data distribution and achieve acceptable quality metrics for the given application's requirements.\n\nUnrolling (or unfolding) for a finite number of steps is a standard, straightforward technique for approximating RNNs by FIR sequences. However, due to the truncation inherent in limiting the number of steps, the resulting unfolded RNN model introduces artificial discontinuities in the approximated version of the target output sequence. In general, the more steps are included in the unrolled RNN subsequence, the closer it can get to the desired output samples, but the less efficient the system becomes, due to the increased number of computations. Nevertheless, if the underlying distribution governing the application generates the sequence under consideration as a series of independent segments (subsequences), then by Proposition 1, an unfolded RNN model aligned with each segment can be trained to reproduce outputs from inputs in a way that aims to satisfy the appropriate criteria of merit faithfully. In this sense, Proposition 1 for RNNs loosely resembles in spirit the Sampling Theorem in the field of Discrete-Time Signal Processing [1]. The method of unrolling is also applicable to the scenarios where attention can be restricted to those 'present' sections of the output that are influenced to an arbitrarily small extent by the portions of the 'past' or the 'future' of the input beyond some arbitrarily large but finite step [2]. As a matter of fact, in certain situations, the raw data set may be amenable to pre-processing, without losing much of the essential information. Suppose that after a suitable cleanup, treating the overall sequence as a collection of independent segments becomes a reasonable assumption. Then by Proposition 1, the adverse effects of truncation can be reduced by adjusting the number of samples comprising the window of the unrolled RNN system. Moreover, whenever Proposition 1 applies, the segments can be processed by the unrolled RNN system in any order (because they are assumed to be independent). This flexibility is utilized by the modules that split the original data set into segments and feed the batches of segmented training samples to the computational core of system.\n\nConversely, if the assumptions of Proposition 1 are violated, then truncating the unrolling will prevent the model from adequately fitting the ground truth output. To illustrate this point, suppose that an RNN system, unrolled for a relatively few steps, is being used to fit the target sequence that exhibits extremely long-range dependencies. The unrolled RNN subsequence will be trained under the erroneous assumptions, expecting the ground truth to be a series of short independent subsequences. However, because of its relatively narrow window, this RNN subsequence will not be able to encompass enough samples to capture the dependencies present in the actual data. Under-sampling the distribution will limit the flow of information from the training samples to the parameters of the model, leaving it in the constant state of making poor predictions. As a symptom, the model will repeatedly encounter unexpected variations during training, causing the objective function to oscillate, never converging to an adequate optimum. During inference, the generated sequence will suffer from severe jitter and distortion when compared to the expected output.\n\nRemark 4 . According to Proposition 1, the RNN unrolling technique is justified by partitioning a single output sequence into multiple independent subsequences and placing restrictions on the initialization of the state between subsequences. However, adhering to these conditions may be problematic in terms of modeling sequences in practical applications. Oftentimes, the output subsequences exhibit some inter-dependence and/or the initial state of one subsequence is influenced by the final state of another subsequence. In practice, if the choice for the initial conditions of the state of subsequences is consistent with the process by which the application generates the samples of the input sequence, then a favorable subdivision of the output sequence into acceptably independent subsequences can be found empirically through experimentation and statistical analysis.",
        "metadata": {
            "section_header": "III. RNN UNFOLDING/UNROLLING",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## IV. RNN TRAINING DIFFICULTIES\n\nProposition 1 establishes that Equations 73 - 77 together with Equation 42 specify the truncated unrolled RNN system that realizes the standard RNN system, given by Equation 32 and Equation 33. We now segue to the analysis of the training technique for obtaining the weights in the truncated unrolled RNN system, with the focus on Equation 74 and Equation 75.\n\nOnce the infinite RNN sequence in Equation 32 is truncated (or unrolled to a finite length), the resulting system, given in Equation 74, becomes inherently stable. However, RNN systems are problematic in practice, despite their stability. During training, they suffer from the well-documented issues, known as 'vanishing gradients' and 'exploding gradients' [21, 22, 44]. These difficulties become pronounced when the dependencies in the target subsequence span a large number of samples, requiring the window of the unrolled RNN model to be commensurately wide in order to capture these long-range dependencies.\n\nTruncated unrolled RNN systems, such as Equation 74, are commonly trained using 'Back Propagation Through Time' (BPTT), which is the 'Back Propagation' technique adapted for sequences [43, 67, 73, 74]. The essence of Back Propagation is the repeated application of the chain rule of differentiation. Computationally, the action of unrolling Equation 32 for K steps amounts to converting its associated directed graph having a delay and a cycle, into a directed acyclic graph (DAG) corresponding to Equation 74. For this reason, while originally Back Propagation was restricted to feedforward networks only, subsequently, it has been successfully applied to recurrent networks by taking advantage of the very fact that for every recurrent network there exists an equivalent feedforward network with identical behavior for a finite number of steps [39, 52, 53].\n\nAs a supervised training algorithm, BPTT utilizes the available ⃗ ˜ x m [ n ] and ⃗ n ˜[ r ] data pairs (or the respective pairs of some mappings of these quantities) in the training set to compute the parameters of the system, Θ , defined in Equation 49, so as to optimize an objective function, E , which depends on the readout signal, ⃗ n ˜[ r ] , at one or more values of the index, n . If Gradient Descent (or another 'gradient type' algorithm) is used to optimize E , then BPTT provides a consistent procedure for deriving the elements of ∂E ∂ Θ through a repeated application of the chain rule 12 .\n\nBy assuming that the conditions of Proposition 1 apply, the objective function, E , takes on the same form for all segments. Let us now apply BPTT to Equation 74. Suppose that E depends on the readout signal, ⃗ n ˜[ r ] , at some specific value of the index, n . Then it is reasonable to wish to measure the total gradient of E with respect to ⃗ n ˜[ r ] :\n\n<!-- formula-not-decoded -->\n\nSince ⃗ n ˜[ r ] is explicitly dependent on ⃗ n ˜[ s ] , it follows that ⃗ n ˜[ s ] also influences E , and one should be interested in measuring the total gradient of E with respect to ⃗ n ˜[ s ] :\n\n<!-- formula-not-decoded -->\n\nQuite often in practice, the overall objective function is defined as the sum of separate contributions involving the readout signal, ⃗ n ˜[ r ] , at each individual value of the index, n :\n\n<!-- formula-not-decoded -->\n\nBecause of the presence of the individual penalty terms, E ⃗ r n (˜[ ]) , in Equation 80 for the overall objective function of the system, it may be tempting to use the chain rule directly with respect to ⃗ n ˜[ r ] in isolation and simply conclude that ⃗ n χ [ ] in Equation 78 is equal to ∂E ⃗ r n (˜[ ]) ∂ ⃗ n ˜[ r ] ⊙ dG d ( ⃗ z ) d⃗ z ⌋ z =˜[ ⃗ n s ] , where the ⊙ operator denotes the element-wise vector product. However, this would miss an important additional component of the gradient with respect to the state signal. The subtlety is that for an RNN, the state signal, ⃗ n ˜[ s ] , at n = k also influences the state signal, ⃗ n ˜[ s ] , at n = k +1 [15, 44]. The dependency of ⃗ n ˜[ s +1] on ⃗ n ˜[ s ] through ⃗ n ˜[ r ] becomes apparent by rewriting Equation 74 at the index, n +1 :\n\n<!-- formula-not-decoded -->\n\n12 The name 'Back Propagation Through Time' reflects the origins of recurrent neural networks in continuous-time domain and differential equations. While not strictly accurate, given the discrete nature of the RNN system under consideration, 'Back Propagation Through Time' is easy to remember, carries historical significance, and should not be the source of confusion.\n\nHence, accounting for both dependencies, while applying the chain rule, gives the expressions for the total partial derivative of the objective function with respect to the readout signal and the state signal at the index, n :\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nEquation 82 and Equation 84 show that the total partial derivatives of the objective function form two sequences, which progress in the 'backward' direction of the index, n . These sequences represent the dual counterparts of the sequence generated by unrolling Equation 74 in the 'forward' direction of the index, n . Therefore, just as Equation 74 requires the initialization of the segment's state signal using Equation 73, the sequence formed by the total partial derivative of the objective function with respect to the state signal (commonly designated as the 'the error gradient') requires that Equation 82 must also be initialized:\n\n<!-- formula-not-decoded -->\n\nApplying the chain rule to Equation 74 and using Equation 84, gives the expressions for the derivatives of the model's parameters:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nNote that for an RNN cell, unrolled for K m steps in order to cover a segment containing K m training samples, the same set of the model parameters, Θ , is shared by all the steps. This is because Θ is the parameter of the RNN system as a whole. Consequently, the total derivative of the objective function, E , with respect to the model parameters, Θ , has to include the contributions from all steps of the unrolled sequence. This is captured in Equation 90, which can now be used as part of optimization by Gradient Descent. Another key observation is that according to Equation 87, Equation 88, and Equation 89, all of the quantities essential for updating the parameters of the system, Θ , during training are directly proportional to ⃗ n ψ [ ] .\n\nWhen the RNN system is trained using BPTT, the error gradient signal flows in the reverse direction of the index, n , from that of the sequence itself. Let 〈 ⃗ k ψ [ ] 〉 ⌋ 0 ≤ k&lt;n denote all terms of the sequence, each of whose elements, ⃗ k ψ [ ] , is the gradient of E with respect to the state signal, ⃗ k ˜[ s ] , at the index, k , for all k &lt; n , ending at ⃗ k ψ [ = 0] , the start of the sequence. Then Equation 84 reveals that ⃗ n ψ [ ] , the gradient of E with respect to the state signal, ⃗ n ˜[ s ] , at some value of the index, n , no matter how large, can influence the entire ensemble, 〈 ⃗ k ψ [ ] 〉 ⌋ 0 ≤ k&lt;n . Furthermore, by Proposition 1, ⃗ n ψ [ ] depends on the truncated ensemble, 〈 ⃗ k ψ [ ] 〉 ⌋ n&lt;k ≤ K m -1 . Thus, of a particular interest is the fraction of ⃗ n ψ [ ] that is retained from back propagating ⃗ l ψ [ ] , where l ≫ n . This component of the gradient of the objective function is responsible for adjusting the model's parameters, Θ , in a way that uses the information available at one sample to reduce the cost of the system making an error at a distant sample. If these types of contributions to ⃗ n ψ [ ] ⌋ 0 ≤ ≤ n K m -1 are well-behaved numerically, then the model parameters learned by using the Gradient Descent optimization procedure will able to incorporate the long-range interactions among the samples in the RNN window effectively during inference.\n\nExpanding the recursion in Equation 84 from the step with the index, n, to the step with the index, l ≤ K m -1 , where l ≫ n , gives:\n\n<!-- formula-not-decoded -->\n\nFrom Equation 91, the magnitude of the overall Jacobian matrix, ∂ ⃗ n ψ [ ] ∂ ⃗ l ψ [ ] , depends on the product of l -n individual Jacobian matrices, W r ⊙ dG ⃗ z ( ) d⃗ z ⌋ z =˜[ ⃗ k s ] 13 . Even though the truncated unrolled RNN system is guaranteed to be stable by design, since in the case of long-range interactions the unrolled window size, K m , and the distance between the samples of interest, l -n , are both large, the stability analysis is helpful in estimating the magnitude of ∂ ⃗ n ψ [ ] ∂ ⃗ l ψ [ ] in Equation 91. If all eigenvalues, µ i , of W r satisfy the requirement for stability, 0 &lt; µ i &lt; 1 , then ∥ W r ∥ &lt; 1 . Combined with the fact that ∥ ∥ ∥ dG ⃗ z ( ) d⃗ z ∥ ∥ ∥ &lt; 1 (which follows\n\nfrom the choice of the warping function advocated in Section II), this yields:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nl -n\n\nConversely, if at least one eigenvalue of W r violates the requirement for stability, the term ∥ W r ∥ will grow exponentially. This can lead to two possible outcomes for the RNN system in Equation 74. In one scenario, as the state signal, ⃗ n ˜[ s ] , grows, the elements of the readout signal, ⃗ n ˜[ r ] , eventually saturate at the 'rails' (the flat regions) of the warping function. Since in the saturation regime, dG ⃗ z ( ) d⃗ z = 0 ⃗ , the result is again ∥ ∥ ∥ ∂ ⃗ n ψ [ ] ∂ ⃗ l ψ [ ] ∥ ∥ ∥ ≈ 0 . In another, albeit rare, scenario, the state signal, ⃗ n ˜[ s ] , is initially biased in the quasi-linear region of the warping function, where dG ⃗ z ( ) d⃗ z = 0 ⃗ . If the input, ⃗ ˜ x m [ n ] , then guides the system to stay in this mode for a large number of steps, ∥ ∥ ∥ ∂ ⃗ n ψ [ ] ∂ ⃗ l ψ [ ] ∥ ∥ ∥ will grow, potentially resulting in an overflow. Consequently, training the standard RNN system on windows spanning many data samples using Gradient Descent is hampered by either vanishing or exploding gradients, regardless of whether or not the system is large-signal stable. In either case, as long as Gradient Descent optimization is used for training the RNN, regulating ⃗ n ψ [ ] will be challenging in practice, leaving no reliable mechanism for updating the parameters of the system, Θ , in a way that would enable the trained RNN model to infer both ⃗ n ˜[ r ] and ⃗ l ˜[ r ≫ n ] optimally 14 . The most effective solution so far is the Long Short-Term Memory (LSTM) cell architecture [15, 21, 43, 44].\n\n̸",
        "metadata": {
            "section_header": "IV. RNN TRAINING DIFFICULTIES",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## V. FROM RNN TO VANILLA LSTM NETWORK\n\nThe Long Short-Term Memory (LSTM) network was invented with the goal of addressing the vanishing gradients problem. The key insight in the LSTM design was to incorporate nonlinear, data-dependent controls into the RNN cell, which can be trained to ensure that the gradient of the objective function with respect to the state signal (the quantity directly proportional to the parameter updates computed during training by Gradient Descent) does not vanish [21]. The LSTM cell can be rationalized from the canonical RNN cell by reasoning about Equation 30 and introducing changes that make the system robust and versatile.\n\nIn the RNN system, the observable readout signal of the cell is the warped version of the cell's state signal itself. A weighted copy of this warped state signal is fed back from one step to the next as part of the update signal to the cell's state. This tight coupling between the readout signal at one step and the state signal at the next step directly impacts the gradient of the objective function with respect to the state signal. This impact is compounded during the training phase, culminating in the vanishing/exploding gradients.\n\nSeveral modifications to the cell's design can be undertaken to remedy this situation. As a starting point, it is useful to separate the right hand side of Equation 30 (the cell's updated state signal at a step with the index, n ) into two parts 15 :\n\n<!-- formula-not-decoded -->\n\n⃗ r\n\n[\n\nn\n\n]\n\n=\n\nG\n\nd\n\n(\n\n⃗ s\n\n[\n\nn\n\n])\n\n(95)\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n15 In the remainder of this document, the prototype segment notation of Equation 74 is being omitted for simplicity. Unless otherwise specified, it is assumed that all operations are intended to be on the domain of a segment, where the sample index, n, traverses the steps of the segment, 0 ≤ n ≤ K m -1 , for every segment with the index, m , in 0 ≤ m ≤ M -1 .\n\nwhere G d ( ⃗ z ) is the hyperbolic tangent as before 16 . The first part, ⃗ F s ( ⃗ s [ n -1]) , carries forward the contribution from the state signal at the previous step. The second part, ⃗ F u ( ⃗ r [ n -1] , ⃗ x n [ ]) , represents the update information, consisting of the combination of the readout signal from the previous step and the input signal (the external driving force) at the current step (plus the bias vector, ⃗ θ s ) 17 . According to Equation 94, the state signal blends both sources of information in equal proportions at every step. These proportions can be made adjustable by multiplying the two quantities by the special 'gate' signals, ⃗ g cs [ n ] ('control state') and ⃗ g cu [ n ] ('control update'), respectively:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nFig. 4. Expanding the canonical RNN system by adding the 'control state' gate, ⃗ g cs [ n ] , to control the amount of the state signal, retained from the previous step and the 'control update' gate, ⃗ g cu [ n ] , to regulate the amount of the update signal - to be injected into the state signal at the current step.\n\n<!-- image -->\n\nThe elements of gate signals are non-negative fractions. The shorthand notation, ⃗ g [ n ] ∈ [0 ⃗ , ⃗ 1] (alternatively, ⃗ 0 ≤ ⃗ g [ n ] ≤ ⃗ 1 ), means that the values of all elements of a vector-valued gate signal, ⃗ g [ n ] , at a step with the index, n , lie on a closed segment between 0 and 1 .\n\nThe gate signals, ⃗ g cs [ n ] and ⃗ g cu [ n ] , in Equation 98 and Equation 99 provide a mechanism for exercising a fine-grained control of the two types of contributions to the state signal at every step. Specifically, ⃗ g cs [ n ] makes it possible to control the amount of the state signal, retained from the previous step, and ⃗ g cu [ n ] regulates the amount of the update signal - to be injected into the state signal at the current step 18 .\n\n17 In discrete systems, the concept of time is only of historical significance. The proper terminology would be to use the word 'adjacent' when referring to quantities at the neighboring steps. Here, the terms 'previous', 'current', and 'next' are sometimes used only for convenience purposes. The RNN systems can be readily unrolled in the opposite direction, in which case all indices are negated and the meaning of 'previous' and 'next' is reversed. As a matter of fact, improved performance has been attained with bi-directional processing in a variety of applications [15, 17, 32, 55, 58, 78]. Moreover, if the input data is prepared ahead of time and is made available to the system in its entirety, then the causality restriction can be relaxed altogether. This can be feasible in applications, where the entire training data set or a collection of independent training data segments is gathered before processing commences. Non-causal processing (i.e., a technique characterized by taking advantage of the input data 'from the future') can be advantageous in detecting the presence of 'context' among data samples. Utilizing the information at the 'future' steps as part of context for making decisions at the 'current' step is often beneficial for analyzing audio, speech, and text.\n\n18 The significance of the element-wise control of the 'content' signals (here called the 'data' signals) exerted by the gates in the LSTM network has been independently recognized and researched by others [29].\n\nFrom the derivation of the standard RNN system in Section II, W s in Equation 96 is a diagonal matrix with positive fractions, 1 | a ii | , on its main diagonal. Hence, since the elements of ⃗ g cs [ n ] are also fractions, setting:\n\n<!-- formula-not-decoded -->\n\nin ⃗ g cs [ n ] ⊙ W s is acceptable as long as the gate functions are parametrizable and their parameters are learned during training. Under these conditions, Equation 96 can be simplified to:\n\n<!-- formula-not-decoded -->\n\nso that Equation 98 becomes:\n\n<!-- formula-not-decoded -->\n\nHence, the contribution from the state signal at the previous step remains fractional, insuring the stability of the overall system. Diagrammatically, the insertion of the expanded controls from Equation 102 into the canonical RNN system of Equation 30 transforms Figure 1 into Figure 4.\n\nWhile the update term, ⃗ F u ( ⃗ r [ n -1] , ⃗ x n [ ]) , as a whole is now controlled by ⃗ g cu [ n ] , the internal composition of ⃗ F u ( ⃗ r [ n -1] , ⃗ x n [ ]) itself needs to be examined. According to Equation 97, the readout signal from the previous step and the input signal at the current step constitute the update candidate signal on every step with the index, n , with both of these terms contributing in equal proportions. The issue with always utilizing W ⃗ r n r [ -1] in its entirety is that when ⃗ g cu [ n ] ∼ 1 , ⃗ s [ n -1] and ⃗ s [ n ] become connected through W r and the warping function. Based on Equation 91, this link constrains the gradient of the objective function with respect to the state signal, thus predisposing the system to the vanishing/exploding gradients problem. To throttle this feedback path, the readout signal, ⃗ r [ n ] , will be apportioned by another gate signal, ⃗ g cr [ n ] ('control readout'), as follows:\n\n<!-- formula-not-decoded -->\n\nThe gating control, ⃗ g cr [ n ] , determines the fractional amount of the readout signal that becomes the cell's observable value signal at the step with the index, n . Thus, using ⃗ v [ n -1] in place of ⃗ r [ n -1] in Equation 97 transforms it into:\n\n<!-- formula-not-decoded -->\n\nThe RNN cell schematic diagram, expanded to accommodate the control readout gate, introduced in Equation 103, and the modified recurrence relationship, employed in Equation 105, appears in Figure 5.\n\nEven though the external input does not affect the system's stability or impact its susceptibility to vanishing/exploding gradients, pairing the input with its own 'control input' gate makes the system more flexible.\n\nMultiplying the external input signal, ⃗ x [ n ] , in Equation 97 by a dedicated gate signal, ⃗ g cx [ n ] , turns Equation 105 into:\n\n<!-- formula-not-decoded -->\n\nAccording to Equation 103 and Equation 106, utilizing both the control readout gate, ⃗ g cr [ n ] , and the control input gate, ⃗ g cx [ n ] , allows for the update term, ⃗ F u ( ⃗ v [ n -1] , ⃗ x n [ ]) , to contain an arbitrary mix of the readout signal and the external input. The control input gate signal, ⃗ g cx [ n ] , will be later incorporated as part of extending the Vanilla LSTM cell. For now, it is assumed for simplicity that ⃗ g cx [ n ] = 1 ⃗ , so Equation 106 reduces to Equation 105.\n\nThe dynamic range of the value signal of the cell, ⃗ v [ n ] , is determined by the readout signal, ⃗ r [ n ] , which is bounded by the warping nonlinearity, G d ( z ) . In order to maintain the same dynamic range while absorbing the contributions from the input signal, ⃗ x [ n ] (or ⃗ g cx [ n ] ⊙ ⃗ x [ n ] if the control input gate is part of the system architecture), the aggregate signal, ⃗ F u ( ⃗ v [ n -1] , ⃗ x n [ ]) , is tempered by the saturating warping nonlinearity, G d ( z ) , so as to produce the update candidate signal, ⃗ u [ n ] :\n\n<!-- formula-not-decoded -->\n\nThus, replacing the update term in Equation 102 with ⃗ u [ n ] , given by Equation 107, finally yields 19 :\n\n<!-- formula-not-decoded -->\n\n19 Note the notation change: in the rest of the document, the symbol, ⃗ u [ n ] , has the meaning of the update candidate signal (not the vector-valued unit step function).\n\nFig. 5. The 'control readout' gate, ⃗ g cr [ n ] , determines the fractional amount of the readout signal that becomes the cell's observable value signal at the current step.\n\n<!-- image -->\n\nwhich is a core constituent of the set of formulas defining the cell of the Vanilla LSTM network. According to Equation 108, the state signal of the cell at the current step is a weighted combination of the state signal of the cell at the previous step and the aggregation of historical and novel update information available at the present step. The complete data path of the Vanilla LSTM cell, culminating from fortifying the canonical RNN system with gating controls and signal containment, is illustrated in Figure 6.\n\nExample 2. For an idealized illustration of the ability of the LSTM cell to propagate the error gradient unattenuated, set ⃗ g cs [ n ] to ⃗ 1 and both, ⃗ g cu [ n ] and ⃗ g cr [ n ] , to ⃗ 0 for all steps in the segment. Then ⃗ s [ n ] = [ ⃗ s n -1] and ⃗ n ψ [ ] = ⃗ n ψ [ +1] for all steps in the segment. The inventors of the LSTM network named this mode the 'Constant Error Carousel' (CEC) to underscore that the error gradient is recirculated and the state signal of the cell is refreshed on every step 20 . Essentially, the multiplicative gate units open and close access to constant error gradient flow through CEC as part of the operation of the LSTM cell 21 [12, 21].\n\nIn Section IV, we saw that the error gradient determines the parameter updates for training the standard RNN by Gradient Descent. It will become apparent in Section VI-I that the same relationship holds for the Vanilla LSTM network as well. The difference is that because of the gates, the function for the error gradient of the LSTM network accommodates Gradient Descent better than that of the standard RNN does. As will be shown in Section VI-J, under certain provisions regarding the model parameters, the unrolled Vanilla LSTM cell operates in the CEC mode. If such a parameter combination emerges during training, then the parameter update information, embedded in the error gradient signal, will be back-propagated over a large number of steps of a training subsequence, imparting sensitivity to the long-range dependencies to the model parameters through the parameter update step of Gradient Descent. If the training process steers the model parameters toward causing ∥ ⃗ g cs [ n ] ∥ = 1 (as in Example 2), then the LSTM network circumvents the vanishing gradient problem in this asymptotic case.\n\nFig. 6. In the Vanilla LSTM network, the state signal of the cell at the current step is a weighted combination of the state signal of the cell at the previous step and the aggregation of historical and novel update information available at the present step.\n\n<!-- image -->\n\nAnalogously to the standard RNN, the Vanilla LSTM network, trained by Gradient Descent, can also learn the short-range dependencies among the samples of the subsequences, comprising the training data. Suppose that during training the model parameters cause ∥ ⃗ g cs [ n ] ∥ &lt; 1 (unlike in Example 2). Then, as will be elaborated in Section VI-J, the error gradient signal will decline, eventually vanishing over a finite number of steps, even if during training ∥ ⃗ g cu [ n ] ∥ &gt; 0 and/or ∥ ⃗ g cr [ n ] ∥ &gt; 0 so as to admit (by Equation 108) the contributions from the update candidate signal, ⃗ u [ n ] , into the composition of the state signal.\n\nIt remains to define the expressions for the gate signals, ⃗ g cs [ n ] , ⃗ g cr [ n ] , and ⃗ g cu [ n ] . Assuming that the system will be trained with BPTT, all of its constituent functions, including the functions for the gate signals, must be differentiable. A convenient function that is continuous, differentiable, monotonically increasing, and maps the domain ( -∞ ∞ , ) into the range (0 , 1) is the logistic function:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhich is a shifted, scaled, and re-parameterized replica of the hyperbolic tangent, used as the warping function, G d ( z ) , for the data signals in RNN and LSTM systems. When operating on vector arguments, G ⃗ z c ( ) is computed by applying Equation 109 to each element of the vector, ⃗ z , separately; the same rule applies to G d ( ⃗ z ) .\n\nIn order to determine the fractional values of the control signals, ⃗ g cs [ n ] , ⃗ g cu [ n ] , and ⃗ g cr [ n ] , at the step with the index, n , all the data signals, from as close as possible to the index of the current step, are utilized. Specifically, for both, ⃗ g cs [ n ] , which determines the fraction of the state signal, ⃗ s [ n -1] , from the previous step and ⃗ g cu [ n ] , which determines the fraction of the update candidate signal, ⃗ u [ n ] , from the current step, the available data signals are ⃗ s [ n -1] , ⃗ v [ n -1] , and ⃗ x [ n ] . However, note that for ⃗ g cr [ n ] , which determines the fraction of the readout signal, ⃗ r [ n ] , from the current step, the available data signals are ⃗ s [ n ] , ⃗ v [ n -1] , and ⃗ x [ n ] . This is because by Equation 103, ⃗ r [ n ] is available at the junction of the cell, where ⃗ g cr [ n ] is computed, and hence, by Equation 95, ⃗ s [ n ] is necessarily available. The input to each gate is presented as a linear combination of all the data signals available to it:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nAccumulating the available data signals linearly makes the application of the chain rule for BPTT straightforward, while providing a rich representation of the system's data as an input to each gate at every step. As the model parameters, { W x cr , W x cu , W x cs , W s cs , W v cs , θ ⃗ cs , W s cu , W v cu , θ ⃗ cu , W s cr , W v cr , θ ⃗ cr } , in Equation 112, Equation 113, and Equation 114 are being trained, the gate functions, given by:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nbecome attuned to the flow of and the variations in the training data through the system at every step. During inference, this enables the gates to modulate their corresponding data signals adaptively, utilizing all the available information at every step. In particular, the gates help to detect and mitigate the detrimental ramifications of artificial boundaries, which arise in the input sequences, due to the implicit truncation, caused by unrolling [37, 49, 76]. The gates make the LSTM system a robust model that compensates for the imperfections in the external data and is capable of generating high quality output sequences.\n\nThis concludes the derivation of the Vanilla LSTM network. The next section presents a formal self-contained summary of the Vanilla LSTM system, including the equations for training it using BPTT.",
        "metadata": {
            "section_header": "V. FROM RNN TO VANILLA LSTM NETWORK",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## VI. THE VANILLA LSTM NETWORK MECHANISM IN DETAIL",
        "metadata": {
            "section_header": "VI. THE VANILLA LSTM NETWORK MECHANISM IN DETAIL",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## A. Overview\n\nSuppose that an LSTM cell is unrolled for K steps. The LSTM cell at the step with the index, n (in the sequence of K steps), accepts the input signal, ⃗ x [ n ] , and computes the externally-accessible (i.e., observable) signal, ⃗ v [ n ] . The internal state signal of the cell at the step with the index, n , is maintained in ⃗ s [ n ] , which is normally not observable by entities external to the cell 22 . However, the computations, associated with the cell at the next adjacent step in the increasing order of the index, n (i.e., the LSTM step at the index, n +1 ), are allowed to access ⃗ s [ n ] , the state signal of the LSTM cell at the step with the index, n .\n\nThe key principle of the LSTM cell centers around organizing its internal operations according to two qualitatively different, yet cooperating, objectives: data and the control of data. The data components prepare the candidate data signals (ranging between -1 and 1 ), while the control components prepare the 'throttle' signals (ranging between 0 and 1 ). Multiplying the candidate data signal by the control signal apportions the fractional amount of the candidate data that is allowed to propagate to its intended nodes in the cell. Hence, if the control signal is 0 , then 0% of the candidate data amount will propagate. Conversely, if the control signal is 1, then 10 0% of the candidate data amount will propagate. Analogously, for intermediate values of the control signal (in the range between 0 and 1 ), the corresponding percentage of the candidate data amount will be made available to the next function in the cell.\n\nAs depicted in Figure 7, the Vanilla LSTM cell contains three candidate-data/control stages: update, state, and readout.\n\n22 In certain advanced RNN and LSTM configurations, such as Attention Networks, the state signal is externally observable and serves as an important component of the objective function.",
        "metadata": {
            "section_header": "A. Overview",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## B. Notation\n\nThe following notation is used consistently throughout this section to define the Vanilla LSTM cell:\n\n- · n - index of a step in the segment (or subsequence); n = 0 , . . . , K -1\n- · K - number of steps in the unrolled segment (or subsequence)\n- · G c - monotonic, bipolarly-saturating warping function for control/throttling purposes (acts as a 'gate')\n- · G d - monotonic, negative-symmetric, bipolarly-saturating warping function for data bounding purposes\n- · d x - dimensionality of the input signal to the cell\n- · d s - dimensionality of the state signal of the cell\n- · ⃗ x ∈ R d x - the input signal to the cell\n- · ⃗ s ∈ R d s - the state signal of the cell\n- · ⃗ v ∈ R d s - the observable value signal of the cell for external purposes (e.g., for connecting one step to the next adjacent step of the same cell in the increasing order of the step index, n ; as input to another cell in the cascade of cells; for connecting to the signal transformation filter for data output; etc.)\n- · ⃗ a ∈ R d s - an accumulation node of the cell (linearly combines the signals from the preceding step and the present step as net input to a warping function at the present step; each cell contains several purpose-specific control and data accumulation nodes)\n- · ⃗ u ∈ R d s - the update candidate signal for the state signal of the cell\n- · ⃗ r ∈ R d s - the readout candidate signal of the cell\n- · g ∈ R d s - a gate output signal of the cell for control/throttling purposes\n- · E ∈ R - objective (cost) function to be minimized as part of the model training procedure\n- · ⃗ x T ⃗ v - vector-vector inner product (yields a scalar)\n- · ⃗ x⃗ v T - vector-vector outer product (yields a matrix)\n- · W⃗ v - matrix-vector product (yields a vector)\n- · ⃗ x ⊙ ⃗ v - element-wise vector product (yields a vector)",
        "metadata": {
            "section_header": "B. Notation",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## C. Control/Throttling ('Gate') Nodes\n\nThe Vanilla LSTM cell uses three gate types:\n\n- · control of the fractional amount of the update candidate signal used to comprise the state signal of the cell at the present step with the index, n\n- · control of the fractional amount of the state signal of the cell at the adjacent lower-indexed step, n -1 , used to comprise the state signal of the cell at the present step with the index, n\n- · control of the fractional amount of the readout candidate signal used to release as the externally-accessible (observable) signal of the cell at the present step with the index, n",
        "metadata": {
            "section_header": "C. Control/Throttling ('Gate') Nodes",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## D. Data Set Standardization\n\nBefore the operation of the LSTM network (or its parent, RNN) can commence, the external training data set, ⃗ x 0 [ n ] , needs to be standardized, such that all elements of the input to the network, ⃗ x [ n ] , have the mean of 0 and the standard deviation of 1 over the training set:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nApplying the transformations in Equation 118, Equation 119, and Equation 120 to the external training samples, ⃗ x 0 [ n ] , accomplishes this task. In these equations, N is the number of samples in the training set, ⃗ µ is the sample mean, and V is the sample auto-covariance matrix of the training set 23 .",
        "metadata": {
            "section_header": "D. Data Set Standardization",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## E. Warping (Activation) Functions\n\nAs described in Section VI-A, the warping function for control needs to output a value between 0 and 1 . The sigmoidal (also known as 'logistic') nonlinearity is a good choice, because it is bipolarly-saturating between these values and is monotonic, continuous, and differentiable:\n\n<!-- formula-not-decoded -->\n\nRelated to this function, the hyperbolic tangent is a suitable choice for the warping function for data bounding purposes:\n\n<!-- formula-not-decoded -->\n\nbecause it is monotonic, negative-symmetric, and bipolarly-saturating at -1 and 1 (i.e., one standard deviation of ⃗ x [ n ] in each direction). This insures that the data warping function, G d ( z ) , will support both negative and positive values of the standardized incoming data signal, ⃗ x [ n ] , in Equation 120, and keep it bounded within that range (the 'squashing' property).",
        "metadata": {
            "section_header": "E. Warping (Activation) Functions",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## F. Vanilla LSTM Cell Model Parameters\n\nThe Vanilla LSTM cell model uses the following fifteen (15) parameter entities (with their respective dimensions and designations as indicated below):\n\n1) Parameters of the accumulation node, ⃗ a cu [ n ] , of the gate that controls the fractional amount of the update candidate signal, ⃗ u [ n ] , used to comprise the state signal of the cell at the present step with the index, n :\n\n- · W x cu ∈ R d s × d x - the matrix of weights connecting the input signal, ⃗ x [ n ] , at the present step with the index, n , to the 'control update' accumulation node, ⃗ a cu [ n ] , of the cell at the present step with the index, n\n- · W s cu ∈ R d s × d s - the matrix of weights connecting the state signal, ⃗ s [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'control update' accumulation node, ⃗ a cu [ n ] , of the cell at the present step with the index, n\n- · W v cu ∈ R d s × d s - the matrix of weights connecting the externally-accessible (observable) value signal, ⃗ v [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'control update' accumulation node, ⃗ a cu [ n ] , of the cell at the present step with the index, n\n- · ⃗ b cu ∈ R d s - the vector of bias elements for the 'control update' accumulation node, ⃗ a cu [ n ] , of the cell at the present step with the index, n\n- 2) Parameters of the accumulation node, ⃗ a cs [ n ] , of the gate that controls the fractional amount of the state signal of the cell, ⃗ s [ n -1] , at the adjacent lower-indexed step, n -1 , used to comprise the state signal of the cell at the present step with the index, n :\n- · W x cs ∈ R d s × d x - the matrix of weights connecting the input signal, ⃗ x [ n ] , at the present step with the index, n , to the 'control state' accumulation node, ⃗ a cs [ n ] , of the cell at the present step with the index, n\n- · W s cs ∈ R d s × d s - the matrix of weights connecting the state signal, ⃗ s [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'control state' accumulation node, ⃗ a cs [ n ] , of the cell at the present step with the index, n\n- · W v cs ∈ R d s × d s - the matrix of weights connecting the externally-accessible (observable) value signal, ⃗ v [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'control state' accumulation node, ⃗ a cs [ n ] , of the cell at the present step with the index, n\n- · ⃗ b cs ∈ R d s - the vector of bias elements for the 'control state' accumulation node, ⃗ a cs [ n ] , of the cell at the present step with the index, n\n- 3) Parameters of the accumulation node, ⃗ a cr [ n ] , of the gate that controls the fractional amount of the readout candidate signal, ⃗ r [ n ] , used to release as the externally-accessible (observable) value signal of the cell at the present step with the index, n :\n- · W x cr ∈ R d s × d x - the matrix of weights connecting the input signal, ⃗ x [ n ] , at the present step with the index, n , to the 'control readout' accumulation node, ⃗ a cr [ n ] , of the cell at the present step with the index, n\n- · W s cr ∈ R d s × d s - the matrix of weights connecting the state signal, ⃗ s [ n ] , at the present step with the index, n , to the 'control readout' accumulation node, ⃗ a cr [ n ] , of the cell at the present step with the index, n\n- · W v cr ∈ R d s × d s - the matrix of weights connecting the externally-accessible (observable) value signal, ⃗ v [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'control readout' accumulation node, ⃗ a cr [ n ] , of the cell at the present step with the index, n\n- · ⃗ b cr ∈ R d s - the vector of bias elements for the 'control readout' accumulation node, ⃗ a cr [ n ] , of the cell at the present step with the index, n\n\n- 4) Parameters of the accumulation node, ⃗ a du [ n ] , for the data warping function that produces the update candidate signal, ⃗ u [ n ] , of the cell at the present step with the index, n :\n- · W x du ∈ R d s × d x - the matrix of weights connecting the input signal, ⃗ x [ n ] , at the present step with the index, n , to the 'data update' accumulation node, ⃗ a du [ n ] , of the cell at the present step with the index, n\n- · W v du ∈ R d s × d s - the matrix of weights connecting the externally-accessible (observable) value signal, ⃗ v [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'data update' accumulation node, ⃗ a du [ n ] , of the cell at the present step with the index, n\n- · ⃗ b du ∈ R d s - the vector of bias elements for the 'data update' accumulation node, ⃗ a du [ n ] , of the cell at the present step with the index, n\n- 5) All model parameters, which must be learned, combined (for notational convenience):\n- · All parameters of the LSTM network are commonly concatenated and represented as a whole by Θ :\n\n<!-- formula-not-decoded -->\n\n- · Arranged 'thematically' (attributed by the type of an accumulation), Θ can be written as:\n\n<!-- formula-not-decoded -->\n\n- G. Summary of the main entities (generalized)\n\nThe following glossary lists the main entities of the model in a generalized way (i.e., without the subscripts, indices, etc.). Note that the special quantities ⃗ ,⃗, ⃗ , ⃗, ⃗ ψ χ α ρ γ will be defined in Section VI-I.\n\n<!-- formula-not-decoded -->\n\nIt is important to highlight the general pattern of computations that govern the processes, according to which any RNN cell, and the LSTM network cell in particular, unrolled for K steps, generates sequences of samples. Namely, the quantities that characterize the step of the cell at the index, n , of the sequence depend on the quantities that characterize the step of the cell at the index, n -1 , of the sequence 24 . The following equations fully define the Vanilla LSTM cell:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nThe schematic diagram of the Vanilla LSTM cell, defined by Equations 126 - 136, is presented in Figure 7, and the snapshot of unrolling it (for only 4 steps as an illustration) appears in Figure 8. In order to make it easier to isolate the specific functions performed by the components of the Vanilla LSTM cell, its schematic diagram is redrawn in Figure 9, with the major stages comprising the cell's architecture marked by dashed rectangles annotated by the names of the respective enclosed stages.\n\nFig. 7. Vanilla LSTM network cell. The bias parameters, ⃗ b, have been omitted from the figure for brevity. They can be assumed to be included without the loss of generality by appending an additional element, always set to 1 , to the input signal vector, ⃗ x [ n ] , and increasing the row dimensions of all corresponding weight matrices by 1 .\n\n<!-- image -->\n\n24 If the cell is unrolled in the opposite direction, then n -1 is replaced by n +1 , and the direction of evaluating the steps is reversed. For the bi-directional unrolling, the steps in both the positive and the negative directions of the index, n , need to be evaluated [58]. Here, only the positive direction is considered.\n\nFig. 8. Sequence of steps generated by unrolling a cell of the LSTM network (displaying 4 steps for illustration).\n\n<!-- image -->\n\nFig. 9. Vanilla LSTM network cell from Figure 7, with the stages of the system delineated by dashed rectangles and annotations that depict the function of each stage. As before, the bias parameters, ⃗ b, have been omitted from the figure for brevity. (They can be assumed to be included without the loss of generality by appending an additional element, always set to 1 , to the input signal vector, ⃗ x [ n ] , and increasing the row dimensions of all corresponding weight matrices by 1 .)\n\n<!-- image -->",
        "metadata": {
            "section_header": "F. Vanilla LSTM Cell Model Parameters",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## I. Vanilla LSTM System Derivatives ('Backward Pass')\n\nThis section derives the equations that are necessary for training the Vanilla LSTM network cell, unrolled for K steps, using Back Propagation Through Time (BPTT). To obtain the update equations for the parameters of the system, two auxiliary 'backward-moving' gradient sequences, indexed by n , are computed first: ⃗ n χ [ ] , the total partial derivative of the objective function, E , with respect to the externally-accessible (observable) value signal, ⃗ v [ n ] , and ⃗ n ψ [ ] , the total partial derivative of the objective function, E , with respect to the state signal, ⃗ s [ n ] . The decision to 'anchor' the chain rule at the border of the cell is made judiciously, guided by the principles of modular design. Expressing every intra-cell total partial derivative in terms of ⃗ n χ [ ] (instead of explicitly computing the total partial derivative of the objective function, E , with respect to each variable of the cell [42]) reduces the number of intermediate variables. This makes the equations for the backward pass straightforward and a natural fit for an implementation as a pluggable module [15, 73, 74].\n\nDue to the backward-moving recursion of ⃗ n χ [ ] and ⃗ n ψ [ ] (the gradient sequences propagate in the direction opposite to that of the state signal, ⃗ s [ n ] , as a function of the step index, n ), the values of ⃗ n χ [ ] and ⃗ n ψ [ ] at the index, n , depend on the values of the same quantities at the index, n +1 , subject to the initial conditions. Once ⃗ n χ [ ] and ⃗ n ψ [ ] are known, they are used to compute the total partial derivatives of the objective function, E , with respect to the accumulation nodes for each value of the index, n . These intermediate gradient sequences, named ⃗ α cs [ n ] , ⃗ α cu [ n ] , ⃗ α cr [ n ] , and ⃗ α du [ n ] , allocate the amounts contributed by the signals associated with the step at the index, n , to the total partial derivatives of the objective function, E , with respect to the model parameters. By the definition of the total derivative, these contributions have to be summed across all steps, 0 ≤ n ≤ K -1 , to produce the total partial derivatives of the objective function, E , with respect to the model parameters.\n\nDuring the inference phase of the LSTM system, only ⃗ x [ n ] (the input signal) and ⃗ v [ n ] (the value signal) are externally accessible (i.e., observable). The cell accepts the input signal at each step and computes the value signal for all steps. All the other intermediate signals are available only to the internal components and nodes of the cell, with the exception of ⃗ s [ n ] (state signal) and ⃗ v [ n ] (value signal), which serve both the inter- and the intra-step purposes throughout the unrolled sequence.\n\nThe cell's value signal, ⃗ v [ n ] , at the step with the index, n , can be further transformed to produce the output signal, ⃗ y [ n ] (e.g., a commonly used form of ⃗ y [ n ] may be obtained by computing a linear transformation of ⃗ v [ n ] , followed by a softmax operator, or a different decision function). Likewise, the input signal, too, may result from the transformation of the original raw data. For example, one kind of input pre-processing can convert the vocabulary 'one-hot' vector into a more compact representation. Also, for applications where the input data set can be collected for the entire segment at once, input samples that lie within a small window surrounding the given step can be combined so as to enhance the system's 'attention' to context. A non-causal input filter, designed for this purpose, will be introduced in Section VII-A as part of extending the Vanilla LSTM cell.\n\nWe start by computing the derivatives of the warping functions from their definitions in Equation 121 and Equation 122, respectively:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nNext, we anchor the chain rule at the border of the cell by defining ⃗ n χ [ ] as the total partial derivative of the objective function, E , with respect to the externally-accessible (observable) value signal, ⃗ v [ n ] , as follows:\n\n<!-- formula-not-decoded -->\n\nAs will become imminently evident, having ⃗ n χ [ ] not only makes training equations for the Vanilla LSTM cell amenable for a modular implementation at the step level, but also greatly simplifies them.\n\nWe also define the total partial derivatives of the objective function, E , with respect to three intermediate (i.e., away from the border) variables and another border variable of the Vanilla LSTM cell:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nThe border quantity in Equation 143, ⃗ n ψ [ ] , is of special significance as it is the total partial derivative of the objective function, E , with respect to the state signal, ⃗ s [ n ] , at the index, n , of the Vanilla LSTM cell. As in the standard RNN, all parameter updates in the Vanilla LSTM network depend on ⃗ n ψ [ ] , making it the most important error gradient sequence of the system.\n\nThe backward pass equations are obtained by utilizing these border and intermediate derivatives in the application of the chain rule to the Vanilla LSTM cell, defined by Equations 126 - 136:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nare the portions of the total derivative of the objective function, E , with respect to the cell's value signal and the cell's state signal, respectively, contributed by the quantities evaluated at the step with the index, n +1 .\n\nThe total partial derivatives of the objective function, E , with respect to the model parameters at the step with the index, n , are directly proportional to the 'accumulation derivatives' 25 , given by Equation 147, Equation 151, Equation 152, and\n\nwhere:\n\nEquation 153. Hence, by referring once again to the definition of the Vanilla LSTM cell in Equations 126 - 136, we obtain:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n∂E\n\n∂W\n\ns\n\ncr\n\n<!-- formula-not-decoded -->\n\n∂E\n\n∂ ⃗\n\nb\n\ncr\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nArranged congruently with Equation 124, the total partial derivative of the objective function, E , with respect to the model parameters, Θ , at the step with the index, n , is:\n\n<!-- formula-not-decoded -->\n\nWhen the Vanilla LSTM cell is unrolled for K steps in order to cover one full segment of training samples, the same set of the model parameters, Θ , is shared by all the steps. This is because Θ is the parameter of the Vanilla LSTM cell as a whole. Consequently, the total derivative of the objective function, E , with respect to the model parameters, Θ , has to include the contributions from all steps of the unrolled sequence:\n\n<!-- formula-not-decoded -->\n\nThe result from Equation 172 can now be used as part of optimization by Gradient Descent. In practice, Equation 172 is computed for a batch of segments 26 , and the sum of the parameter gradients over all segments in the batch is then supplied to the Gradient Descent algorithm for updating the model parameters 27 .\n\n[\n\nn\n\n]\n\n=\n\n⃗\n\nα\n\n[\n\nn\n\n]\n\n(167)\n\n[\n\nn\n\n]\n\n=\n\n⃗\n\nα\n\n[\n\nn ⃗\n\n]\n\ns\n\nT\n\n[\n\nn\n\n]\n\n(165)\n\ncr\n\ncr",
        "metadata": {
            "section_header": "I. Vanilla LSTM System Derivatives ('Backward Pass')",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## J. Error Gradient Sequences in Vanilla LSTM System\n\nSection V mentions that because of the action of the gates, the LSTM network is more compatible with the Gradient Descent training procedure than the standard RNN system is. As discussed in Section IV and Section VI-I, for Gradient Descent to be effective, the elements of ∂E ∂ Θ [ n ] in Equation 171 must be well-behaved numerically. In particular, this implies that the intermediate gradient sequences, ⃗ α cs [ n ] , ⃗ α cu [ n ] , ⃗ α cr [ n ] , and ⃗ α du [ n ] , and hence the border gradient sequences, ⃗ n χ [ ] and ⃗ n ψ [ ] , must be able to sustain a steady flow of information over long ranges of the step index, n . Expanding Equation 150 produces:\n\n<!-- formula-not-decoded -->\n\nAccording to Equation 154 and Equation 155, both ⃗ n χ [ ] and ⃗ n ψ [ ] depend on ⃗ n ψ [ +1] . Hence, we can follow the approach in Section IV to analyze the dependence of ⃗ n ψ [ ] on 〈 ⃗ k ψ [ ] 〉 ⌋ n&lt;k ≤ K -1 in order to gauge the sensitivity of the LSTM system to factors conducive to gradient decay. Applying the change of indices, n -→ k -1 , and the chain rule to Equation 174 yields 28 :\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nAssuming that the issue of 'exploding gradients' is handled as a separate undertaking, the present focus is on the effectiveness of the LSTM network at assuaging the 'vanishing gradients' problem. If the value of the total partial derivative of the objective function, E , with respect to the state signal, ⃗ s [ l ] , at the index, l ≤ K -1 , where l ≫ n , is considered to be an impulse of the error gradient, then Equation 180 computes the fractional amount of this corrective stimulus that did not dissipate across the large number ( l -n ) of steps and is preserved in ⃗ n ψ [ ] , thereby able to contribute to updating the model parameters.\n\nThe propensity of the LSTM system toward diminishing error gradients during training can be assessed by evaluating the different modes of Equation 179 that can cause ∥ ∥ ∥ ∂ ⃗ n ψ [ ] ∂ ⃗ l ψ [ ] ∥ ∥ ∥ ≈ 0 in Equation 180 when l -n is large. A sufficient condition for driving the residual ∥ ∥ ∥ ∂ ⃗ n ψ [ ] ∂ ⃗ l ψ [ ] ∥ ∥ ∥ to zero is maintaining ∥ ∥ ∥ ∂ ⃗ k ψ [ -1] ∂ ⃗ k ψ [ ] ∥ ∥ ∥ &lt; 1 at each step with the index, k . There are three possibilities for this outcome:\n\n- · Q k ( -1 , k ; Θ ˜ ) = 0 [ ] and ⃗ g cs [ k ] = 0 ⃗ for all values of the step index, k . This is the case of the network being perpetually 'at rest' (i.e., in a trivial state), which is not interesting from the practical standpoint.\n- · ⃗ g cs [ k ] ≈ ⃗ 1 and Q k ( -1 , k ; Θ ˜ ) = -diag [ ⃗ g cs [ k ] ] ; in other words, Q k ( -1 , k ; Θ ˜ ) and diag [ ⃗ g cs [ k ] ] out' for some value of the step index, k . all signals, which is highly unlikely to occur in practice, making this pathological case unrealistic.\n- · The spectral radius of Q k ( -1 , k ; Θ ˜ ) +diag ⃗ g cs [ k ] in Equation 179 is less than unity for all values of the step index, k . In this situation, the error gradient will degrade to negligible levels after a sufficiently large number of steps. Nevertheless, this behavior would not be due to a degenerate mode of the system, but as a consequence of the particular patterns, occurring in the training data. In other words, some dependencies are naturally short-range.\n- 'cancel each other However, satisfying this condition would require a very careful orchestration of [ [ ]]\n\nFor all remaining cases, the magnitude of ∂ ⃗ k ψ [ -1] ∂ ⃗ k ψ [ ] is governed by the triangle inequality:\n\n<!-- formula-not-decoded -->\n\nThe most emblematic regime of the LSTM network arises when ∥ ∥ ∥ Q k ( -1 , k ; Θ ˜ )∥ ∥ ∥ &lt; 1 . Examining the terms in Equation 178 exposes multiple ways of restricting signals and parameters that would create favorable circumstances for this to hold. The following list prescribes several plausible alternatives (all conditions in each arrangement must be satisfied) 29 :\n\n- · ∥ W s cu ∥ &lt; 1 2 , ∥ W v cu ∥ &lt; 1 2 , ∥ W s cs ∥ &lt; 1 2 , ∥ W v cs ∥ &lt; 1 2 , ∥ W v du ∥ &lt; 1\n- · the state signal saturates the readout data warping function, ∥ W s cr ∥ &lt; 1 2 , ∥ W s cu ∥ &lt; 1 2 , ∥ W s cs ∥ &lt; 1 2\n- · the state signal saturates the readout data warping function, the accumulation signal for the control readout gate saturates its control warping function, ∥ W s cu ∥ &lt; 1 2 , ∥ W s cs ∥ &lt; 1 2\n- · the control readout gate is turned off, ∥ W s cu ∥ &lt; 1 2 , ∥ W s cs ∥ &lt; 1 2\n- · the accumulation signals for the control update gate and the control state gate saturate their respective control warping functions, the update candidate accumulation signal saturates the update candidate data warping function\n- · the control update gate is turned off, the control state gate is turned off\n\nSince the difference between the step indices, l -n , is large when the network is trained to represent long-range dependencies, the powers of the Q k ( -1 , k ; Θ ˜ ) terms become negligible, ultimately leading to:\n\n<!-- formula-not-decoded -->\n\nUnlike Q k ( -1 , k ; Θ ˜ ) , diag [ ⃗ g cs [ k ] ] in Equation 179 has no attenuating factors (the multiplier of ⃗ g cs [ n +1] ⊙ ⃗ n ψ [ +1] in Equation 155 is the identity matrix). As long as the elements of ⃗ g cs [ n ] are fractions, the error gradient will naturally decay. However, if the model is trained to saturate ⃗ g cs [ n ] at ⃗ 1 , then the error gradient is recirculated through Constant Error Carousel.",
        "metadata": {
            "section_header": "J. Error Gradient Sequences in Vanilla LSTM System",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## VII. EXTENSIONS TO THE VANILLA LSTM NETWORK\n\nSince its invention, many variants and extensions of the original LSTM network model have been researched and utilized in practice. In this section, we will evolve the Vanilla LSTM architecture, derived in Section V and explained in depth in Section VI, along three avenues. Based on the analysis in Section II as well as the discussions in Section V and Section VI-I, we will expand the input from consisting of a single sample to combining multiple samples within a small context window. In addition, as proposed in Section V, we will introduce a new gate for controlling this richer input signal. Besides these two novel extensions, we will also include the 'recurrent projection layer' in the augmented model, because it proved to be advantageous in certain sequence modeling applications [55].",
        "metadata": {
            "section_header": "VII. EXTENSIONS TO THE VANILLA LSTM NETWORK",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## A. External Input Context Windows\n\nWe will represent the external input context windows by linear filters that have matrix-valued coefficients and operate on the sequence of input samples along the dimension of the steps of the sequence produced by unrolling the LSTM cell. In Equations 126 - 129, the matrix-vector products, W x cu ⃗ x [ n ] , W x cs ⃗ x [ n ] , W x cr ⃗ x [ n ] , and W x du ⃗ x [ n ] , respectively, which involve a single input sample, ⃗ x [ n ] , will be replaced by the convolutions of the context window filters, W x cu [ n ] , W x cs [ n ] , W x cr [ n ] , and W x du [ n ] , respectively, with the input signal, ⃗ x [ n ] , thereby involving all input samples within the context window in the computation of the respective accumulation signal. We choose the context window filters to be non-causal (i.e., with the non-zero coefficients defined only for n ≤ 0 ). This will enable the accumulation signals to utilize the input samples from the 'future' steps of the unrolled LSTM cell without excessively increasing the number of parameters to be learned, since the input samples from the 'past' steps will be already absorbed by the state signal, ⃗ s [ n ] , due to recurrence. After making these substitutions, Equations 126 - 129 become:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nTo examine the convolutional terms in more detail, let every context window filter, W n x [ ] (with the respective subscript), have L non-zero matrix-valued terms. For example, if L = 4 , then W x [0] , W x [ -1] , W x [ -2] , and W x [ -3] will be non-zero 30 .\n\nBy the definition of the discrete convolution,\n\n<!-- formula-not-decoded -->\n\nIn the above example, the result on the left hand side of Equation 187 for each step with the index, n , will be influenced by the window spanning 4 input samples: ⃗ x [0] , ⃗ x [1] , ⃗ x [2] , and ⃗ x [3] .\n\nIf we redefine W n x [ ] to be non-zero for n ≥ 0 , then Equation 187 simplifies to:\n\n<!-- formula-not-decoded -->\n\nThe dependence of the left hand side of Equation 188 on the input samples from the 'future' steps of the unrolled LSTM cell is readily apparent from the expression for the convolution sum on the right hand side of Equation 188.\n\nBy taking advantage of the available input samples within a small window surrounding each step of the sequence, the system can learn to 'discern' the context in which the given step occurs. The inspiration for this 'look-ahead' extension comes from the way people sometimes find it beneficial to read forward to the end of the sentence in order to better understand a phrase occurring in the earlier part of the sentence. It would be interesting to explore the relative trade-offs between the cost of adding a small number of parameter matrices to Θ so as to accommodate the input context windows with the computational burden of training a bi-directional LSTM network [58], and to compare the performance of the two architectures on several data sets 31 .",
        "metadata": {
            "section_header": "A. External Input Context Windows",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## B. Recurrent Projection Layer\n\nAnother modification of the Vanilla LSTM cell redefines the cell's value signal to be the product of an additional matrix of weights 32 with the LSTM cell's value signal from Equation 136. To insert the recurrent projection layer into the Vanilla LSTM cell, we adjust Equation 136 as follows:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhere W q dr implements the recurrent projection layer 33 , and the intermediate cell quantity, ⃗ q [ n ] (which we will call the cell's 'qualifier' signal), replaces what used to be the cell's value signal in the Vanilla LSTM cell. The new value signal of the cell from Equation 190 will now be used for computing the accumulation signals in Equations 183 - 186.\n\nLet d v denote the dimensionality of the observable value signal of the cell; then ⃗ v ∈ R d v and W q dr ∈ R d v × d s . The degree to which the dimensionality reduction of the cell's value signal can be tolerated for the given application directly contributes to speeding up the training phase of the system. By allowing d v &lt; d s , the matrix multipliers of all the terms involving ⃗ v [ n -1] , which dominate Equations 183 - 186 (or Equations 126 - 129 in the absence of the external input context windows), will contain correspondingly fewer columns. In contrast, in the Vanilla LSTM cell as covered in Section VI (i.e., without the recurrent projection layer), d v must equal d s , since ⃗ v [ n ] is on the same data path as ⃗ s [ n ] , with no signal transformations along the data path between them. Hence, the addition of the recurrent projection layer to the Vanilla LSTM cell brings about the flexibility of trading off the representational capacity of the cell with the computational cost of learning its parameters [55].",
        "metadata": {
            "section_header": "B. Recurrent Projection Layer",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## C. Controlling External Input with a New Gate\n\nSection V argues that the two components of the data update accumulation node, ⃗ a du [ n ] , in the Vanilla LSTM cell are not treated the same way from the standpoint of control. While the readout candidate signal is throttled by the control readout gate, ⃗ g cr [ n ] , the external input is always injected at the full 100% contribution of its signal strength. This is not as much of an issue for the control accumulation nodes ( ⃗ a cu [ n ] , ⃗ a cs [ n ] , and ⃗ a cr [ n ] ), because they influence the scaling of the data signals, not the relative mixing of the data signals themselves. However, since the data update accumulation node, ⃗ a du [ n ] , is directly in the path of the cell's state signal, the ability to regulate both components of ⃗ a du [ n ] can improve the cell's capacity to adapt to the nuances and fluctuations in the training data. For instance, the control readout gate, ⃗ g cr [ n ] , can diminish the effect of the cell's readout signal from the adjacent step in favor of making the external input signal at the given step more prominent in the make up of the cell's state signal. Likewise, having the additional flexibility to fine-tune the external input component of ⃗ a du [ n ] at the same granularity as its readout component (i.e., at the level of the individual step with the index, n ) would provide a means for training the LSTM cell to suppress interference due to noisy or spurious input samples.\n\nAs a mechanism for adjusting the contribution of the external input, Equation 106 introduced the control input gate, ⃗ g cx [ n ] , which we will apply to the convolution term in Equation 186. Analogously to the other gates, ⃗ g cx [ n ] is computed by taking the warping function for control, given by Equation 121, of the accumulation signal for controlling the input, element by element.\n\nFrom Section VI-F and Equation 186, the data update accumulation node, ⃗ a du [ n ] , is followed by the data warping function that produces the update candidate signal, ⃗ u [ n ] , of the cell at the present step with the index, n . The new control input gate, ⃗ g cx [ n ] , will throttle W x du [ n ] ∗ ⃗ x [ n ] , the term representing the composite external input signal in Equation 186 for ⃗ a du [ n ] . Letting ⃗ ξ x du [ n ] ≡ W x du [ n ] ∗ ⃗ x [ n ] , where ⃗ ξ x du [ n ] denotes the composite external input signal for the data update accumulation node, ⃗ a du [ n ] , this gating operation will be accomplished through the element-wise multiplication, ⃗ g cx [ n ] ⊙ ⃗ ξ x du [ n ] , the method used by all the other gates to control the fractional amount of their designated data signals.\n\nThe equations for accommodating the new control input gate, ⃗ g cx [ n ] , as part of the LSTM cell design as well as the equation for the data update accumulation node, ⃗ a du [ n ] , modified to take advantage of this new gate, are provided below:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n32 This new matrix of weights, to be learned as part of training, is known as the 'recurrent projection layer' [55].\n\nwhere the additional parameters, needed to characterize the accumulation node, ⃗ a cx [ n ] , of the new control input gate, ⃗ g cx [ n ] , have the following interpretation:\n\n- · W x cx [ l ] ∈ R d s × d x - the matrices of weights (for 0 ≤ l ≤ L -1 ) connecting the input signal, ⃗ x [ n + ] l , at the step with the index, n + l , to the 'control input' accumulation node, ⃗ a cx [ n ] , of the cell at the present step with the index, n\n- · W s cx ∈ R d s × d s - the matrix of weights connecting the state signal, ⃗ s [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'control input' accumulation node, ⃗ a cx [ n ] , of the cell at the present step with the index, n\n- · W v cx ∈ R d s × d v - the matrix of weights connecting the externally-accessible (observable) value signal, ⃗ v [ n -1] , at the adjacent lower-indexed step with the index, n -1 , to the 'control input' accumulation node, ⃗ a cx [ n ] , of the cell at the present step with the index, n\n- · ⃗ b cx ∈ R d s - the vector of bias elements for the 'control input' accumulation node, ⃗ a cx [ n ] , of the cell at the present step with the index, n\n- · W x du [ l ] ∈ R d s × d x - the matrices of weights (for 0 ≤ l ≤ L -1 ) connecting the input signal, ⃗ x [ n + ] l , at the step with the index, n + l , to the 'data update' accumulation node, ⃗ a du [ n ] , of the cell at the present step with the index, n",
        "metadata": {
            "section_header": "C. Controlling External Input with a New Gate",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## D. Augmented LSTM System Equations ('Forward Pass')\n\nWe are now ready to assemble the equations for the Augmented LSTM system by enhancing the Vanilla LSTM network with the new functionality, presented earlier in this section - the recurrent projection layer, the non-causal input context windows, and the input gate:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwith the dimensions of the parameters adjusted to take into account the recurrent projection layer:\n\nW x cu [ l ] ∈ R d s × d x , W s cu ∈ R d s × d s , W v cu ∈ R d s × d v , ⃗ b cu ∈ R d s , W x cs [ l ] ∈ R d s × d x , W s cs ∈ R d s × d s , W v cs ∈ R d s × d v , ⃗ b cs ∈ R d s , W x cr [ l ] ∈ R d s × d x , W s cr ∈ R d s × d s , W v cr ∈ R d s × d v , ⃗ b cr ∈ R d s , W x cx [ l ] ∈ R d s × d x , W s cx ∈ R d s × d s , W v cx ∈ R d s × d v , ⃗ b cx ∈ R d s , ⃗ b\n\nW x du [ l ] ∈ R d s × d x , W v du ∈ R d s × d v , du ∈ R d s , and W q dr ∈ R d v × d s , where 0 ≤ l ≤ L -1 and d v ≤ d s .\n\nThe schematic diagram of the Augmented LSTM cell appears in Figure 10.\n\nCombining all the matrix and vector parameters of the Augmented LSTM cell, described by Equations 196 - 214, into:\n\n<!-- formula-not-decoded -->\n\ncompletes the definition of the inference phase (forward pass) of the Augmented LSTM cell.\n\n(a) Augmented LSTM network cell. The bias parameters, ⃗ b, have been omitted from the figure for brevity. They can be assumed to be included without the loss of generality by appending an additional element, always set to 1 , to the input signal vector, ⃗ x [ n ] , and increasing the row dimensions of all corresponding weight matrices by 1 . To minimize clutter in the diagram, the context windows are shown separately in Figure 10b below).\n\n<!-- image -->\n\n(b) The non-causal context windows, implemented as the convolutions (along the dimension of the sequence index, n ) of the external input, ⃗ x [ n ] , with linear filters, whose coefficients are matrix-valued. The operations in this figure compute the quantities of the form ⃗ ξ x [ n ] = W n x [ ] ∗ ⃗ x [ n ] , corresponding to their respective subscripts.\n\n<!-- image -->\n\nFig. 10. Augmented LSTM network cell system schematics.\n\nThe equations for training the Augmented LSTM cell, unrolled for K steps, using BPTT, are obtained by adopting the same method as was used for the Vanilla LSTM cell in Section VI-I. We rely on the same border and intermediate total partial derivatives, appearing in Equations 139 - 143, with the addition of the total partial derivative of the objective function, E , with respect to the qualifier signal, ⃗ q [ n ] :\n\n<!-- formula-not-decoded -->\n\nwhich is an intermediate total partial derivative that reflects the insertion of the projection layer into the cell's data path. Applying the chain rule to the Augmented LSTM cell, defined by Equations 196 - 214, and judiciously utilizing all of these border and intermediate total partial derivatives, yields the backward pass equations for the Augmented LSTM cell:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n⃗ n ψ [\n\n]\n\n=\n\n⃗ n ρ [\n\n]\n\n⊙\n\n=\n\n⃗ n\n\nρ\n\n[\n\n]\n\n⊙\n\n∂⃗ r\n\n[\n\nn\n\n]\n\n∂⃗ s\n\n[\n\nn\n\n]\n\ndG\n\nd\n\n(\n\n⃗ z\n\n)\n\nd⃗ z\n\n+\n\n⌋\n\nz\n\n= [\n\n∂⃗ a\n\ncr\n\n∂⃗ s\n\n[\n\nn\n\n]\n\n⃗ s\n\nn\n\n]\n\n⃗\n\nα\n\n+\n\nW\n\ncr\n\n[\n\nn\n\n] +\n\ns\n\ncr\n\n⃗\n\nα\n\nf\n\ncr\n\n⃗\n\n[\n\nn\n\n] +\n\n[\n\nn\n\n+1]\n\n⃗\n\nf\n\nψ\n\n[\n\nn\n\n+1]\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nα\n\n⃗\n\n[\n\nn\n\n]\n\n=\n\n⃗ γ\n\n[\n\nn\n\n]\n\n⊙\n\n∂⃗ g\n\ncx\n\n∂⃗ a\n\ncx\n\n[\n\nn\n\n]\n\n[\n\nn\n\n]\n\ndG\n\nc\n\n(\n\nz\n\n)\n\ndz\n\ndG\n\nc\n\n(\n\nz\n\n)\n\ndz\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n=\n\n⃗ γ\n\n[\n\nn\n\n]\n\n⊙\n\n⌋\n\n=\n\n⃗\n\nα\n\n[\n\nn\n\n]\n\n⊙\n\n⃗\n\nξ\n\n[\n\nn\n\n]\n\n⊙\n\n⌋\n\n[\n\nn\n\n]\n\nwhere:\n\ncx\n\ncx\n\ncx\n\nψ\n\nz\n\n=\n\n⃗ a\n\ncx\n\n[\n\nn\n\n]\n\ndu\n\nx\n\ndu\n\nz\n\n=\n\n⃗ a\n\ncx\n\n[\n\nn\n\n]\n\nReferring once again to the definition of the Augmented LSTM cell in Equations 196 - 214, we obtain:\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n∂E\n\n∂W\n\ns\n\ncs\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\n<!-- formula-not-decoded -->\n\nwhere 0 ≤ l ≤ L -1 and 0 ≤ n ≤ K -1 . Arranged to parallel the structure of Θ , defined in Equation 215, the total partial derivative of the objective function, E , with respect to the model parameters, Θ , at the step with the index, n , is:\n\n<!-- formula-not-decoded -->\n\n[\n\nn\n\n]\n\n=\n\n⃗\n\nα\n\n[\n\nn ⃗\n\n]\n\ns\n\nT\n\n[\n\nn\n\n-\n\n1]\n\n(235)\n\ncs\n\nFinally, dE d Θ , the total derivative of the objective function, E , with respect to the model parameters, Θ , for the entire unrolled sequence is computed by Equation 172. Aggregated over a batch of segments, dE d Θ is plugged in to the Gradient Descent training algorithm for learning the model parameters, Θ .",
        "metadata": {
            "section_header": "D. Augmented LSTM System Equations ('Forward Pass')",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## VIII. CONCLUSIONS AND FUTURE WORK\n\nIn this paper, we presented the fundamentals of the RNN and the LSTM network using a principled approach. Starting with the differential equations encountered in many branches of science and engineering, we showed that the canonical formulation of the RNN can be obtained by sampling delay differential equations used to model processes in physics, life sciences, and neural networks. We proceeded to obtain the standard RNN formulation by appropriately choosing the parameters of the canonical RNN equations and applying stability considerations. We then formally explained RNN unrolling within the framework of approximating an IIR system by an FIR model and proved the sufficient conditions for its applicability to learning sequences. Next, we presented the training of the standard RNN using Back Propagation Through Time, segueing to the review of the vanishing and exploding gradients, the well-known numerical difficulties, associated with training the standard RNN by Gradient Descent. We subsequently addressed the shortcomings of the standard RNN by morphing the canonical RNN system into the more robust LSTM network through a series of extensions and embellishments. In addition to the logical construction of the Vanilla LSTM network from the canonical RNN, we included a self-contained overview of the Vanilla LSTM network, complete with the specifications of all principal entities as well as clear, descriptive, yet concise, presentations of the forward pass and, importantly, the backward pass, without skipping any steps. The main contribution up to this point has been our unique pedagogical approach for analyzing the RNN and Vanilla LSTM systems from the Signal Processing perspective, a formal derivation of the RNN unrolling procedure, and a thorough treatment using a descriptive and meaningful notation, aimed at demystifying the underlying concepts. Moreover, as an unexpected benefit of our analysis, we identified two novel extensions to the Vanilla LSTM network: the convolutional non-causal input context windows and the external input gate. We then augmented the equations for the LSTM cell with these extensions (along with the recurrent projection layer, previously introduced by another researcher team). Candidate recommendations for future work include implementing the Augmented LSTM system within a high-performance computing environment and benchmarking its efficacy in multiple practical scenarios. The use of the Augmented LSTM could potentially benefit the language representation subsystems used in question answering and in automating customer support. For these applications, it will be important to evaluate the performance impact, attributed to the non-causal input context windows, as compared to the different baselines, such the Vanilla LSTM network, the bi-directional LSTM network, the Transformer, and other state-of-the-art models. Also of particular relevance to this use case will be to measure the effectiveness of the external input gate in helping to eliminate the non-essential content from the input sequences. Finally, adopting the Augmented LSTM network to other practical domains and publishing the results is respectfully encouraged.",
        "metadata": {
            "section_header": "VIII. CONCLUSIONS AND FUTURE WORK",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    },
    {
        "page_content": "## ACKNOWLEDGMENTS\n\nThe author thanks Eugene Mandel for long-time collaboration and engaging discussions, which were instrumental in clarifying the key concepts, as well as for his encouragement and support. Tremendous gratitude is expressed to Tom Minka for providing helpful critique and valuable comments and to Mike Singer for reviewing the proposition and correcting errors in the proof. Big thanks go to Varuna Jayasiri, Eduardo G. Ponferrada, Flavia Sparacino, and Janet Cahn for proofreading the manuscript.",
        "metadata": {
            "section_header": "ACKNOWLEDGMENTS",
            "title": "Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) Network",
            "type": "paper"
        }
    }
]