[
   {
      "page_content": "has_compile = hasattr(torch, 'compile')\n_logger = logging.getLogger('validate')\nparser = argparse.ArgumentParser(description='PyTorch ImageNet Validation')\nscripting_group = parser.add_mutually_exclusive_group()\n_NON_IN1K_FILTERS = ['*_in21k', '*_in22k', '*in12k', '*_dino', '*fcmae', '*seer']",
      "metadata": {
         "section_header": "Global Variables",
         "type": "python global"
      }
   },
   {
      "page_content": "\"\"\" ImageNet Validation Script\nThis is intended to be a lean and easily modifiable ImageNet validation script for evaluating pretrained\nmodels or training checkpoints against ImageNet or similarly organized image datasets. It prioritizes\ncanonical PyTorch, standard Python style, and good performance. Repurpose as you see fit.\nHacked together by Ross Wightman (https://github.com/rwightman)\n\"\"\"\nimport argparse\nimport csv\nimport glob\nimport json\nimport logging\nimport os\nimport time\nfrom collections import OrderedDict\nfrom contextlib import suppress\nfrom functools import partial\nimport torch\nimport torch.nn as nn\nimport torch.nn.parallel\nfrom timm.data import create_dataset, create_loader, resolve_data_config, RealLabelsImagenet\nfrom timm.layers import apply_test_time_pool, set_fast_norm\nfrom timm.models import create_model, load_checkpoint, is_model, list_models\nfrom timm.utils import accuracy, AverageMeter, natural_key, setup_default_logging, set_jit_fuser, \\\n\tdecay_batch_step, check_batch_size_retry, ParseKwargs, reparameterize_model\ntry:\n\tfrom apex import amp\n\thas_apex = True\nexcept ImportError:\n\thas_apex = False\ntry:\n\tfrom functorch.compile import memory_efficient_fusion\n\thas_functorch = True\nexcept ImportError as e:\n\thas_functorch = False\nparser.add_argument('data', nargs='?', metavar='DIR', const=None,\n\t\t\t\t\thelp='path to dataset (*deprecated*, use --data-dir)')\nparser.add_argument('--data-dir', metavar='DIR',\n\t\t\t\t\thelp='path to dataset (root dir)')\nparser.add_argument('--dataset', metavar='NAME', default='',\n\t\t\t\t\thelp='dataset type + name (\"<type>/<name>\") (default: ImageFolder or ImageTar if empty)')\nparser.add_argument('--split', metavar='NAME', default='validation',\n\t\t\t\t\thelp='dataset split (default: validation)')\nparser.add_argument('--num-samples', default=None, type=int,\n\t\t\t\t\tmetavar='N', help='Manually specify num samples in dataset split, for IterableDatasets.')\nparser.add_argument('--dataset-download', action='store_true', default=False,\n\t\t\t\t\thelp='Allow download of dataset for torch/ and tfds/ datasets that support it.')\nparser.add_argument('--class-map', default='', type=str, metavar='FILENAME',\n\t\t\t\t\thelp='path to class to idx mapping file (default: \"\")')\nparser.add_argument('--input-key', default=None, type=str,\n\t\t\t\t   help='Dataset key for input images.')\nparser.add_argument('--input-img-mode', default=None, type=str,\n\t\t\t\t   help='Dataset image conversion mode for input images.')\nparser.add_argument('--target-key', default=None, type=str,\n\t\t\t\t   help='Dataset key for target labels.')\nparser.add_argument('--dataset-trust-remote-code', action='store_true', default=False,\n\t\t\t\t   help='Allow huggingface dataset import to execute code downloaded from the dataset\\'s repo.')\nparser.add_argument('--model', '-m', metavar='NAME', default='dpn92',\n\t\t\t\t\thelp='model architecture (default: dpn92)')\nparser.add_argument('--pretrained', dest='pretrained', action='store_true',\n\t\t\t\t\thelp='use pre-trained model')\nparser.add_argument('-j', '--workers', default=4, type=int, metavar='N',\n\t\t\t\t\thelp='number of data loading workers (default: 4)')\nparser.add_argument('-b', '--batch-size', default=256, type=int,\n\t\t\t\t\tmetavar='N', help='mini-batch size (default: 256)')\nparser.add_argument('--img-size', default=None, type=int,\n\t\t\t\t\tmetavar='N', help='Input image dimension, uses model default if empty')\nparser.add_argument('--in-chans', type=int, default=None, metavar='N',\n\t\t\t\t\thelp='Image input channels (default: None => 3)')\nparser.add_argument('--input-size', default=None, nargs=3, type=int, metavar='N',\n\t\t\t\t\thelp='Input all image dimensions (d h w, e.g. --input-size 3 224 224), uses model default if empty')\nparser.add_argument('--use-train-size', action='store_true', default=False,\n\t\t\t\t\thelp='force use of train input size, even when test size is specified in pretrained cfg')\nparser.add_argument('--crop-pct', default=None, type=float,\n\t\t\t\t\tmetavar='N', help='Input image center crop pct')\nparser.add_argument('--crop-mode', default=None, type=str,\n\t\t\t\t\tmetavar='N', help='Input image crop mode (squash, border, center). Model default if None.')\nparser.add_argument('--crop-border-pixels', type=int, default=None,\n\t\t\t\t\thelp='Crop pixels from image border.')\nparser.add_argument('--mean', type=float, nargs='+', default=None, metavar='MEAN',\n\t\t\t\t\thelp='Override mean pixel value of dataset')\nparser.add_argument('--std', type=float,  nargs='+', default=None, metavar='STD',\n\t\t\t\t\thelp='Override std deviation of of dataset')\nparser.add_argument('--interpolation', default='', type=str, metavar='NAME',\n\t\t\t\t\thelp='Image resize interpolation type (overrides model)')\nparser.add_argument('--num-classes', type=int, default=None,\n\t\t\t\t\thelp='Number classes in dataset')\nparser.add_argument('--gp', default=None, type=str, metavar='POOL',\n\t\t\t\t\thelp='Global pool type, one of (fast, avg, max, avgmax, avgmaxc). Model default if None.')\nparser.add_argument('--log-freq', default=10, type=int,\n\t\t\t\t\tmetavar='N', help='batch logging frequency (default: 10)')\nparser.add_argument('--checkpoint', default='', type=str, metavar='PATH',\n\t\t\t\t\thelp='path to latest checkpoint (default: none)')\nparser.add_argument('--num-gpu', type=int, default=1,\n\t\t\t\t\thelp='Number of GPUS to use')\nparser.add_argument('--test-pool', dest='test_pool', action='store_true',\n\t\t\t\t\thelp='enable test time pool')\nparser.add_argument('--no-prefetcher', action='store_true', default=False,\n\t\t\t\t\thelp='disable fast prefetcher')\nparser.add_argument('--pin-mem', action='store_true', default=False,\n\t\t\t\t\thelp='Pin CPU memory in DataLoader for more efficient (sometimes) transfer to GPU.')\nparser.add_argument('--channels-last', action='store_true', default=False,\n\t\t\t\t\thelp='Use channels_last memory layout')\nparser.add_argument('--device', default='cuda', type=str,\n\t\t\t\t\thelp=\"Device (accelerator) to use.\")\nparser.add_argument('--amp', action='store_true', default=False,\n\t\t\t\t\thelp='use NVIDIA Apex AMP or Native AMP for mixed precision training')\nparser.add_argument('--amp-dtype', default='float16', type=str,\n\t\t\t\t\thelp='lower precision AMP dtype (default: float16)')\nparser.add_argument('--amp-impl', default='native', type=str,\n\t\t\t\t\thelp='AMP impl to use, \"native\" or \"apex\" (default: native)')\nparser.add_argument('--model-dtype', default=None, type=str,\n\t\t\t\t   help='Model dtype override (non-AMP) (default: float32)')\nparser.add_argument('--tf-preprocessing', action='store_true', default=False,\n\t\t\t\t\thelp='Use Tensorflow preprocessing pipeline (require CPU TF installed')\nparser.add_argument('--use-ema', dest='use_ema', action='store_true',\n\t\t\t\t\thelp='use ema version of weights if present')\nparser.add_argument('--fuser', default='', type=str,\n\t\t\t\t\thelp=\"Select jit fuser. One of ('', 'te', 'old', 'nvfuser')\")\nparser.add_argument('--fast-norm', default=False, action='store_true',\n\t\t\t\t\thelp='enable experimental fast-norm')\nparser.add_argument('--reparam', default=False, action='store_true',\n\t\t\t\t\thelp='Reparameterize model')\nparser.add_argument('--model-kwargs', nargs='*', default={}, action=ParseKwargs)\nparser.add_argument('--torchcompile-mode', type=str, default=None,\n\t\t\t\t\thelp=\"torch.compile mode (default: None).\")\nscripting_group.add_argument('--torchscript', default=False, action='store_true',\n\t\t\t\t\t\t\t help='torch.jit.script the full model')\nscripting_group.add_argument('--torchcompile', nargs='?', type=str, default=None, const='inductor',\n\t\t\t\t\t\t\t help=\"Enable compilation w/ specified backend (default: inductor).\")\nscripting_group.add_argument('--aot-autograd', default=False, action='store_true',\n\t\t\t\t\t\t\t help=\"Enable AOT Autograd support.\")\nparser.add_argument('--results-file', default='', type=str, metavar='FILENAME',\n\t\t\t\t\thelp='Output csv file for validation results (summary)')\nparser.add_argument('--results-format', default='csv', type=str,\n\t\t\t\t\thelp='Format for results file one of (csv, json) (default: csv).')\nparser.add_argument('--real-labels', default='', type=str, metavar='FILENAME',\n\t\t\t\t\thelp='Real labels JSON file for imagenet evaluation')\nparser.add_argument('--valid-labels', default='', type=str, metavar='FILENAME',\n\t\t\t\t\thelp='Valid label indices txt file for validation of partial label space')\nparser.add_argument('--retry', default=False, action='store_true',\n\t\t\t\t\thelp='Enable batch size decay & retry for single model validation')\ndef validate(args):\n\t# might as well try to validate something\n\targs.pretrained = args.pretrained or not args.checkpoint\n\targs.prefetcher = not args.no_prefetcher\n\tif torch.cuda.is_available():\n\t\ttorch.backends.cuda.matmul.allow_tf32 = True\n\t\ttorch.backends.cudnn.benchmark = True\n\tdevice = torch.device(args.device)\n\tmodel_dtype = None\n\tif args.model_dtype:\n\t\tassert args.model_dtype in ('float32', 'float16', 'bfloat16')\n\t\tmodel_dtype = getattr(torch, args.model_dtype)\n\t# resolve AMP arguments based on PyTorch / Apex availability\n\tuse_amp = None\n\tamp_autocast = suppress\n\tif args.amp:\n\t\tassert model_dtype is None or model_dtype == torch.float32, 'float32 model dtype must be used with AMP'\n\t\tif args.amp_impl == 'apex':\n\t\t\tassert has_apex, 'AMP impl specified as APEX but APEX is not installed.'\n\t\t\tassert args.amp_dtype == 'float16'\n\t\t\tuse_amp = 'apex'\n\t\t\t_logger.info('Validating in mixed precision with NVIDIA APEX AMP.')\n\t\telse:\n\t\t\tassert args.amp_dtype in ('float16', 'bfloat16')\n\t\t\tuse_amp = 'native'\n\t\t\tamp_dtype = torch.bfloat16 if args.amp_dtype == 'bfloat16' else torch.float16\n\t\t\tamp_autocast = partial(torch.autocast, device_type=device.type, dtype=amp_dtype)\n\t\t\t_logger.info('Validating in mixed precision with native PyTorch AMP.')\n\telse:\n\t\t_logger.info(f'Validating in {model_dtype or torch.float32}. AMP not enabled.')\n\tif args.fuser:\n\t\tset_jit_fuser(args.fuser)\n\tif args.fast_norm:\n\t\tset_fast_norm()\n\t# create model\n\tin_chans = 3\n\tif args.in_chans is not None:\n\t\tin_chans = args.in_chans\n\telif args.input_size is not None:\n\t\tin_chans = args.input_size[0]\n\tmodel = create_model(\n\t\targs.model,\n\t\tpretrained=args.pretrained,\n\t\tnum_classes=args.num_classes,\n\t\tin_chans=in_chans,\n\t\tglobal_pool=args.gp,\n\t\tscriptable=args.torchscript,\n\t\t**args.model_kwargs,\n\t)\n\tif args.num_classes is None:\n\t\tassert hasattr(model, 'num_classes'), 'Model must have `num_classes` attr if not set on cmd line/config.'\n\t\targs.num_classes = model.num_classes\n\tif args.checkpoint:\n\t\tload_checkpoint(model, args.checkpoint, args.use_ema)\n\tif args.reparam:\n\t\tmodel = reparameterize_model(model)\n\tparam_count = sum([m.numel() for m in model.parameters()])\n\t_logger.info('Model %s created, param count: %d' % (args.model, param_count))\n\tdata_config = resolve_data_config(\n\t\tvars(args),\n\t\tmodel=model,\n\t\tuse_test_size=not args.use_train_size,\n\t\tverbose=True,\n\t)\n\ttest_time_pool = False\n\tif args.test_pool:\n\t\tmodel, test_time_pool = apply_test_time_pool(model, data_config)\n\tmodel = model.to(device=device, dtype=model_dtype)  # FIXME move model device & dtype into create_model\n\tif args.channels_last:\n\t\tmodel = model.to(memory_format=torch.channels_last)\n\tif args.torchscript:\n\t\tassert not use_amp == 'apex', 'Cannot use APEX AMP with torchscripted model'\n\t\tmodel = torch.jit.script(model)\n\telif args.torchcompile:\n\t\tassert has_compile, 'A version of torch w/ torch.compile() is required for --compile, possibly a nightly.'\n\t\ttorch._dynamo.reset()\n\t\tmodel = torch.compile(model, backend=args.torchcompile, mode=args.torchcompile_mode)\n\telif args.aot_autograd:\n\t\tassert has_functorch, \"functorch is needed for --aot-autograd\"\n\t\tmodel = memory_efficient_fusion(model)\n\tif use_amp == 'apex':\n\t\tmodel = amp.initialize(model, opt_level='O1')\n\tif args.num_gpu > 1:\n\t\tmodel = torch.nn.DataParallel(model, device_ids=list(range(args.num_gpu)))\n\tcriterion = nn.CrossEntropyLoss().to(device)\n\troot_dir = args.data or args.data_dir\n\tif args.input_img_mode is None:\n\t\tinput_img_mode = 'RGB' if data_config['input_size'][0] == 3 else 'L'\n\telse:\n\t\tinput_img_mode = args.input_img_mode\n\tdataset = create_dataset(\n\t\troot=root_dir,\n\t\tname=args.dataset,\n\t\tsplit=args.split,\n\t\tdownload=args.dataset_download,\n\t\tload_bytes=args.tf_preprocessing,\n\t\tclass_map=args.class_map,\n\t\tnum_samples=args.num_samples,\n\t\tinput_key=args.input_key,\n\t\tinput_img_mode=input_img_mode,\n\t\ttarget_key=args.target_key,\n\t\ttrust_remote_code=args.dataset_trust_remote_code,\n\t)\n\tif args.valid_labels:\n\t\twith open(args.valid_labels, 'r') as f:\n\t\t\tvalid_labels = [int(line.rstrip()) for line in f]\n\telse:\n\t\tvalid_labels = None\n\tif args.real_labels:\n\t\treal_labels = RealLabelsImagenet(dataset.filenames(basename=True), real_json=args.real_labels)\n\telse:\n\t\treal_labels = None\n\tcrop_pct = 1.0 if test_time_pool else data_config['crop_pct']\n\tloader = create_loader(\n\t\tdataset,\n\t\tinput_size=data_config['input_size'],\n\t\tbatch_size=args.batch_size,\n\t\tuse_prefetcher=args.prefetcher,\n\t\tinterpolation=data_config['interpolation'],\n\t\tmean=data_config['mean'],\n\t\tstd=data_config['std'],\n\t\tnum_workers=args.workers,\n\t\tcrop_pct=crop_pct,\n\t\tcrop_mode=data_config['crop_mode'],\n\t\tcrop_border_pixels=args.crop_border_pixels,\n\t\tpin_memory=args.pin_mem,\n\t\tdevice=device,\n\t\timg_dtype=model_dtype or torch.float32,\n\t\ttf_preprocessing=args.tf_preprocessing,\n\t)\n\tbatch_time = AverageMeter()\n\tlosses = AverageMeter()\n\ttop1 = AverageMeter()\n\ttop5 = AverageMeter()\n\tmodel.eval()\n\twith torch.no_grad():\n\t\t# warmup, reduce variability of first batch time, especially for comparing torchscript vs non\n\t\tinput = torch.randn((args.batch_size,) + tuple(data_config['input_size'])).to(device=device, dtype=model_dtype)\n\t\tif args.channels_last:\n\t\t\tinput = input.contiguous(memory_format=torch.channels_last)\n\t\twith amp_autocast():\n\t\t\tmodel(input)\n\t\tend = time.time()\n\t\tfor batch_idx, (input, target) in enumerate(loader):\n\t\t\tif args.no_prefetcher:\n\t\t\t\ttarget = target.to(device=device)\n\t\t\t\tinput = input.to(device=device, dtype=model_dtype)\n\t\t\tif args.channels_last:\n\t\t\t\tinput = input.contiguous(memory_format=torch.channels_last)\n\t\t\t# compute output\n\t\t\twith amp_autocast():\n\t\t\t\toutput = model(input)\n\t\t\t\tif valid_labels is not None:\n\t\t\t\t\toutput = output[:, valid_labels]\n\t\t\t\tloss = criterion(output, target)\n\t\t\tif real_labels is not None:\n\t\t\t\treal_labels.add_result(output)\n\t\t\t# measure accuracy and record loss\n\t\t\tacc1, acc5 = accuracy(output.detach(), target, topk=(1, 5))\n\t\t\tlosses.update(loss.item(), input.size(0))\n\t\t\ttop1.update(acc1.item(), input.size(0))\n\t\t\ttop5.update(acc5.item(), input.size(0))\n\t\t\t# measure elapsed time\n\t\t\tbatch_time.update(time.time() - end)\n\t\t\tend = time.time()\n\t\t\tif batch_idx % args.log_freq == 0:\n\t\t\t\t_logger.info(\n\t\t\t\t\t'Test: [{0:>4d}/{1}]  '\n\t\t\t\t\t'Time: {batch_time.val:.3f}s ({batch_time.avg:.3f}s, {rate_avg:>7.2f}/s)  '\n\t\t\t\t\t'Loss: {loss.val:>7.4f} ({loss.avg:>6.4f})  '\n\t\t\t\t\t'Acc@1: {top1.val:>7.3f} ({top1.avg:>7.3f})  '\n\t\t\t\t\t'Acc@5: {top5.val:>7.3f} ({top5.avg:>7.3f})'.format(\n\t\t\t\t\t\tbatch_idx,\n\t\t\t\t\t\tlen(loader),\n\t\t\t\t\t\tbatch_time=batch_time,\n\t\t\t\t\t\trate_avg=input.size(0) / batch_time.avg,\n\t\t\t\t\t\tloss=losses,\n\t\t\t\t\t\ttop1=top1,\n\t\t\t\t\t\ttop5=top5\n\t\t\t\t\t)\n\t\t\t\t)\n\tif real_labels is not None:\n\t\t# real labels mode replaces topk values at the end\n\t\ttop1a, top5a = real_labels.get_accuracy(k=1), real_labels.get_accuracy(k=5)\n\telse:\n\t\ttop1a, top5a = top1.avg, top5.avg\n\tresults = OrderedDict(\n\t\tmodel=args.model,\n\t\ttop1=round(top1a, 4), top1_err=round(100 - top1a, 4),\n\t\ttop5=round(top5a, 4), top5_err=round(100 - top5a, 4),\n\t\tparam_count=round(param_count / 1e6, 2),\n\t\timg_size=data_config['input_size'][-1],\n\t\tcrop_pct=crop_pct,\n\t\tinterpolation=data_config['interpolation'],\n\t)\n\t_logger.info(' * Acc@1 {:.3f} ({:.3f}) Acc@5 {:.3f} ({:.3f})'.format(\n\t   results['top1'], results['top1_err'], results['top5'], results['top5_err']))\n\treturn results\ndef _try_run(args, initial_batch_size):\n\tbatch_size = initial_batch_size\n\tresults = OrderedDict()\n\terror_str = 'Unknown'\n\twhile batch_size:\n\t\targs.batch_size = batch_size * args.num_gpu  # multiply by num-gpu for DataParallel case\n\t\ttry:\n\t\t\tif 'cuda' in args.device and torch.cuda.is_available():\n\t\t\t\ttorch.cuda.empty_cache()\n\t\t\telif \"npu\" in args.device and torch.npu.is_available():\n\t\t\t\ttorch.npu.empty_cache()\n\t\t\tresults = validate(args)\n\t\t\treturn results\n\t\texcept RuntimeError as e:\n\t\t\terror_str = str(e)\n\t\t\t_logger.error(f'\"{error_str}\" while running validation.')\n\t\t\tif not check_batch_size_retry(error_str):\n\t\t\t\tbreak\n\t\tbatch_size = decay_batch_step(batch_size)\n\t\t_logger.warning(f'Reducing batch size to {batch_size} for retry.')\n\tresults['model'] = args.model\n\tresults['error'] = error_str\n\t_logger.error(f'{args.model} failed to validate ({error_str}).')\n\treturn results\ndef main():\n\tsetup_default_logging()\n\targs = parser.parse_args()\n\tmodel_cfgs = []\n\tmodel_names = []\n\tif os.path.isdir(args.checkpoint):\n\t\t# validate all checkpoints in a path with same model\n\t\tcheckpoints = glob.glob(args.checkpoint + '/*.pth.tar')\n\t\tcheckpoints += glob.glob(args.checkpoint + '/*.pth')\n\t\tmodel_names = list_models(args.model)\n\t\tmodel_cfgs = [(args.model, c) for c in sorted(checkpoints, key=natural_key)]\n\telse:\n\t\tif args.model == 'all':\n\t\t\t# validate all models in a list of names with pretrained checkpoints\n\t\t\targs.pretrained = True\n\t\t\tmodel_names = list_models(\n\t\t\t\tpretrained=True,\n\t\t\t\texclude_filters=_NON_IN1K_FILTERS,\n\t\t\t)\n\t\t\tmodel_cfgs = [(n, '') for n in model_names]\n\t\telif not is_model(args.model):\n\t\t\t# model name doesn't exist, try as wildcard filter\n\t\t\tmodel_names = list_models(\n\t\t\t\targs.model,\n\t\t\t\tpretrained=True,\n\t\t\t)\n\t\t\tmodel_cfgs = [(n, '') for n in model_names]\n\t\tif not model_cfgs and os.path.isfile(args.model):\n\t\t\twith open(args.model) as f:\n\t\t\t\tmodel_names = [line.rstrip() for line in f]\n\t\t\tmodel_cfgs = [(n, None) for n in model_names if n]\n\tif len(model_cfgs):\n\t\t_logger.info('Running bulk validation on these pretrained models: {}'.format(', '.join(model_names)))\n\t\tresults = []\n\t\ttry:\n\t\t\tinitial_batch_size = args.batch_size\n\t\t\tfor m, c in model_cfgs:\n\t\t\t\targs.model = m\n\t\t\t\targs.checkpoint = c\n\t\t\t\tr = _try_run(args, initial_batch_size)\n\t\t\t\tif 'error' in r:\n\t\t\t\t\tcontinue\n\t\t\t\tif args.checkpoint:\n\t\t\t\t\tr['checkpoint'] = args.checkpoint\n\t\t\t\tresults.append(r)\n\t\texcept KeyboardInterrupt as e:\n\t\t\tpass\n\t\tresults = sorted(results, key=lambda x: x['top1'], reverse=True)\n\telse:\n\t\tif args.retry:\n\t\t\tresults = _try_run(args, args.batch_size)\n\t\telse:\n\t\t\tresults = validate(args)\n\tif args.results_file:\n\t\twrite_results(args.results_file, results, format=args.results_format)\n\t# output results in JSON to stdout w/ delimiter for runner script\n\tprint(f'--result\\n{json.dumps(results, indent=4)}')\ndef write_results(results_file, results, format='csv'):\n\twith open(results_file, mode='w') as cf:\n\t\tif format == 'json':\n\t\t\tjson.dump(results, cf, indent=4)\n\t\telse:\n\t\t\tif not isinstance(results, (list, tuple)):\n\t\t\t\tresults = [results]\n\t\t\tif not results:\n\t\t\t\treturn\n\t\t\tdw = csv.DictWriter(cf, fieldnames=results[0].keys())\n\t\t\tdw.writeheader()\n\t\t\tfor r in results:\n\t\t\t\tdw.writerow(r)\n\t\t\tcf.flush()\nif __name__ == '__main__':\n\tmain()",
      "metadata": {
         "section_header": "Global Other",
         "type": "python global"
      }
   },
   {
      "page_content": "def validate(args):\n\t# might as well try to validate something\n\targs.pretrained = args.pretrained or not args.checkpoint\n\targs.prefetcher = not args.no_prefetcher\n\tif torch.cuda.is_available():\n\t\ttorch.backends.cuda.matmul.allow_tf32 = True\n\t\ttorch.backends.cudnn.benchmark = True\n\tdevice = torch.device(args.device)\n\tmodel_dtype = None\n\tif args.model_dtype:\n\t\tassert args.model_dtype in ('float32', 'float16', 'bfloat16')\n\t\tmodel_dtype = getattr(torch, args.model_dtype)\n\t# resolve AMP arguments based on PyTorch / Apex availability\n\tuse_amp = None\n\tamp_autocast = suppress\n\tif args.amp:\n\t\tassert model_dtype is None or model_dtype == torch.float32, 'float32 model dtype must be used with AMP'\n\t\tif args.amp_impl == 'apex':\n\t\t\tassert has_apex, 'AMP impl specified as APEX but APEX is not installed.'\n\t\t\tassert args.amp_dtype == 'float16'\n\t\t\tuse_amp = 'apex'\n\t\t\t_logger.info('Validating in mixed precision with NVIDIA APEX AMP.')\n\t\telse:\n\t\t\tassert args.amp_dtype in ('float16', 'bfloat16')\n\t\t\tuse_amp = 'native'\n\t\t\tamp_dtype = torch.bfloat16 if args.amp_dtype == 'bfloat16' else torch.float16\n\t\t\tamp_autocast = partial(torch.autocast, device_type=device.type, dtype=amp_dtype)\n\t\t\t_logger.info('Validating in mixed precision with native PyTorch AMP.')\n\telse:\n\t\t_logger.info(f'Validating in {model_dtype or torch.float32}. AMP not enabled.')\n\tif args.fuser:\n\t\tset_jit_fuser(args.fuser)\n\tif args.fast_norm:\n\t\tset_fast_norm()\n\t# create model\n\tin_chans = 3\n\tif args.in_chans is not None:\n\t\tin_chans = args.in_chans\n\telif args.input_size is not None:\n\t\tin_chans = args.input_size[0]\n\tmodel = create_model(\n\t\targs.model,\n\t\tpretrained=args.pretrained,\n\t\tnum_classes=args.num_classes,\n\t\tin_chans=in_chans,\n\t\tglobal_pool=args.gp,\n\t\tscriptable=args.torchscript,\n\t\t**args.model_kwargs,\n\t)\n\tif args.num_classes is None:\n\t\tassert hasattr(model, 'num_classes'), 'Model must have `num_classes` attr if not set on cmd line/config.'\n\t\targs.num_classes = model.num_classes\n\tif args.checkpoint:\n\t\tload_checkpoint(model, args.checkpoint, args.use_ema)\n\tif args.reparam:\n\t\tmodel = reparameterize_model(model)\n\tparam_count = sum([m.numel() for m in model.parameters()])\n\t_logger.info('Model %s created, param count: %d' % (args.model, param_count))\n\tdata_config = resolve_data_config(\n\t\tvars(args),\n\t\tmodel=model,\n\t\tuse_test_size=not args.use_train_size,\n\t\tverbose=True,\n\t)\n\ttest_time_pool = False\n\tif args.test_pool:\n\t\tmodel, test_time_pool = apply_test_time_pool(model, data_config)\n\tmodel = model.to(device=device, dtype=model_dtype)  # FIXME move model device & dtype into create_model\n\tif args.channels_last:\n\t\tmodel = model.to(memory_format=torch.channels_last)\n\tif args.torchscript:\n\t\tassert not use_amp == 'apex', 'Cannot use APEX AMP with torchscripted model'\n\t\tmodel = torch.jit.script(model)\n\telif args.torchcompile:\n\t\tassert has_compile, 'A version of torch w/ torch.compile() is required for --compile, possibly a nightly.'\n\t\ttorch._dynamo.reset()\n\t\tmodel = torch.compile(model, backend=args.torchcompile, mode=args.torchcompile_mode)\n\telif args.aot_autograd:\n\t\tassert has_functorch, \"functorch is needed for --aot-autograd\"\n\t\tmodel = memory_efficient_fusion(model)\n\tif use_amp == 'apex':\n\t\tmodel = amp.initialize(model, opt_level='O1')\n\tif args.num_gpu > 1:\n\t\tmodel = torch.nn.DataParallel(model, device_ids=list(range(args.num_gpu)))\n\tcriterion = nn.CrossEntropyLoss().to(device)\n\troot_dir = args.data or args.data_dir\n\tif args.input_img_mode is None:\n\t\tinput_img_mode = 'RGB' if data_config['input_size'][0] == 3 else 'L'\n\telse:\n\t\tinput_img_mode = args.input_img_mode\n\tdataset = create_dataset(\n\t\troot=root_dir,\n\t\tname=args.dataset,\n\t\tsplit=args.split,\n\t\tdownload=args.dataset_download,\n\t\tload_bytes=args.tf_preprocessing,\n\t\tclass_map=args.class_map,\n\t\tnum_samples=args.num_samples,\n\t\tinput_key=args.input_key,\n\t\tinput_img_mode=input_img_mode,\n\t\ttarget_key=args.target_key,\n\t\ttrust_remote_code=args.dataset_trust_remote_code,\n\t)\n\tif args.valid_labels:\n\t\twith open(args.valid_labels, 'r') as f:\n\t\t\tvalid_labels = [int(line.rstrip()) for line in f]\n\telse:\n\t\tvalid_labels = None\n\tif args.real_labels:\n\t\treal_labels = RealLabelsImagenet(dataset.filenames(basename=True), real_json=args.real_labels)\n\telse:\n\t\treal_labels = None\n\tcrop_pct = 1.0 if test_time_pool else data_config['crop_pct']\n\tloader = create_loader(\n\t\tdataset,\n\t\tinput_size=data_config['input_size'],\n\t\tbatch_size=args.batch_size,\n\t\tuse_prefetcher=args.prefetcher,\n\t\tinterpolation=data_config['interpolation'],\n\t\tmean=data_config['mean'],\n\t\tstd=data_config['std'],\n\t\tnum_workers=args.workers,\n\t\tcrop_pct=crop_pct,\n\t\tcrop_mode=data_config['crop_mode'],\n\t\tcrop_border_pixels=args.crop_border_pixels,\n\t\tpin_memory=args.pin_mem,\n\t\tdevice=device,\n\t\timg_dtype=model_dtype or torch.float32,\n\t\ttf_preprocessing=args.tf_preprocessing,\n\t)\n\tbatch_time = AverageMeter()\n\tlosses = AverageMeter()\n\ttop1 = AverageMeter()\n\ttop5 = AverageMeter()\n\tmodel.eval()\n\twith torch.no_grad():\n\t\t# warmup, reduce variability of first batch time, especially for comparing torchscript vs non\n\t\tinput = torch.randn((args.batch_size,) + tuple(data_config['input_size'])).to(device=device, dtype=model_dtype)\n\t\tif args.channels_last:\n\t\t\tinput = input.contiguous(memory_format=torch.channels_last)\n\t\twith amp_autocast():\n\t\t\tmodel(input)\n\t\tend = time.time()\n\t\tfor batch_idx, (input, target) in enumerate(loader):\n\t\t\tif args.no_prefetcher:\n\t\t\t\ttarget = target.to(device=device)\n\t\t\t\tinput = input.to(device=device, dtype=model_dtype)\n\t\t\tif args.channels_last:\n\t\t\t\tinput = input.contiguous(memory_format=torch.channels_last)\n\t\t\t# compute output\n\t\t\twith amp_autocast():\n\t\t\t\toutput = model(input)\n\t\t\t\tif valid_labels is not None:\n\t\t\t\t\toutput = output[:, valid_labels]\n\t\t\t\tloss = criterion(output, target)\n\t\t\tif real_labels is not None:\n\t\t\t\treal_labels.add_result(output)\n\t\t\t# measure accuracy and record loss\n\t\t\tacc1, acc5 = accuracy(output.detach(), target, topk=(1, 5))\n\t\t\tlosses.update(loss.item(), input.size(0))\n\t\t\ttop1.update(acc1.item(), input.size(0))\n\t\t\ttop5.update(acc5.item(), input.size(0))\n\t\t\t# measure elapsed time\n\t\t\tbatch_time.update(time.time() - end)\n\t\t\tend = time.time()\n\t\t\tif batch_idx % args.log_freq == 0:\n\t\t\t\t_logger.info(\n\t\t\t\t\t'Test: [{0:>4d}/{1}]  '\n\t\t\t\t\t'Time: {batch_time.val:.3f}s ({batch_time.avg:.3f}s, {rate_avg:>7.2f}/s)  '\n\t\t\t\t\t'Loss: {loss.val:>7.4f} ({loss.avg:>6.4f})  '\n\t\t\t\t\t'Acc@1: {top1.val:>7.3f} ({top1.avg:>7.3f})  '\n\t\t\t\t\t'Acc@5: {top5.val:>7.3f} ({top5.avg:>7.3f})'.format(\n\t\t\t\t\t\tbatch_idx,\n\t\t\t\t\t\tlen(loader),\n\t\t\t\t\t\tbatch_time=batch_time,\n\t\t\t\t\t\trate_avg=input.size(0) / batch_time.avg,\n\t\t\t\t\t\tloss=losses,\n\t\t\t\t\t\ttop1=top1,\n\t\t\t\t\t\ttop5=top5\n\t\t\t\t\t)\n\t\t\t\t)\n\tif real_labels is not None:\n\t\t# real labels mode replaces topk values at the end\n\t\ttop1a, top5a = real_labels.get_accuracy(k=1), real_labels.get_accuracy(k=5)\n\telse:\n\t\ttop1a, top5a = top1.avg, top5.avg\n\tresults = OrderedDict(\n\t\tmodel=args.model,\n\t\ttop1=round(top1a, 4), top1_err=round(100 - top1a, 4),\n\t\ttop5=round(top5a, 4), top5_err=round(100 - top5a, 4),\n\t\tparam_count=round(param_count / 1e6, 2),\n\t\timg_size=data_config['input_size'][-1],\n\t\tcrop_pct=crop_pct,\n\t\tinterpolation=data_config['interpolation'],\n\t)\n\t_logger.info(' * Acc@1 {:.3f} ({:.3f}) Acc@5 {:.3f} ({:.3f})'.format(\n\t   results['top1'], results['top1_err'], results['top5'], results['top5_err']))\n\treturn results",
      "metadata": {
         "section_header": "validate",
         "type": "python function"
      }
   },
   {
      "page_content": "def _try_run(args, initial_batch_size):\n\tbatch_size = initial_batch_size\n\tresults = OrderedDict()\n\terror_str = 'Unknown'\n\twhile batch_size:\n\t\targs.batch_size = batch_size * args.num_gpu  # multiply by num-gpu for DataParallel case\n\t\ttry:\n\t\t\tif 'cuda' in args.device and torch.cuda.is_available():\n\t\t\t\ttorch.cuda.empty_cache()\n\t\t\telif \"npu\" in args.device and torch.npu.is_available():\n\t\t\t\ttorch.npu.empty_cache()\n\t\t\tresults = validate(args)\n\t\t\treturn results\n\t\texcept RuntimeError as e:\n\t\t\terror_str = str(e)\n\t\t\t_logger.error(f'\"{error_str}\" while running validation.')\n\t\t\tif not check_batch_size_retry(error_str):\n\t\t\t\tbreak\n\t\tbatch_size = decay_batch_step(batch_size)\n\t\t_logger.warning(f'Reducing batch size to {batch_size} for retry.')\n\tresults['model'] = args.model\n\tresults['error'] = error_str\n\t_logger.error(f'{args.model} failed to validate ({error_str}).')\n\treturn results",
      "metadata": {
         "section_header": "_try_run",
         "type": "python function"
      }
   },
   {
      "page_content": "def main():\n\tsetup_default_logging()\n\targs = parser.parse_args()\n\tmodel_cfgs = []\n\tmodel_names = []\n\tif os.path.isdir(args.checkpoint):\n\t\t# validate all checkpoints in a path with same model\n\t\tcheckpoints = glob.glob(args.checkpoint + '/*.pth.tar')\n\t\tcheckpoints += glob.glob(args.checkpoint + '/*.pth')\n\t\tmodel_names = list_models(args.model)\n\t\tmodel_cfgs = [(args.model, c) for c in sorted(checkpoints, key=natural_key)]\n\telse:\n\t\tif args.model == 'all':\n\t\t\t# validate all models in a list of names with pretrained checkpoints\n\t\t\targs.pretrained = True\n\t\t\tmodel_names = list_models(\n\t\t\t\tpretrained=True,\n\t\t\t\texclude_filters=_NON_IN1K_FILTERS,\n\t\t\t)\n\t\t\tmodel_cfgs = [(n, '') for n in model_names]\n\t\telif not is_model(args.model):\n\t\t\t# model name doesn't exist, try as wildcard filter\n\t\t\tmodel_names = list_models(\n\t\t\t\targs.model,\n\t\t\t\tpretrained=True,\n\t\t\t)\n\t\t\tmodel_cfgs = [(n, '') for n in model_names]\n\t\tif not model_cfgs and os.path.isfile(args.model):\n\t\t\twith open(args.model) as f:\n\t\t\t\tmodel_names = [line.rstrip() for line in f]\n\t\t\tmodel_cfgs = [(n, None) for n in model_names if n]\n\tif len(model_cfgs):\n\t\t_logger.info('Running bulk validation on these pretrained models: {}'.format(', '.join(model_names)))\n\t\tresults = []\n\t\ttry:\n\t\t\tinitial_batch_size = args.batch_size\n\t\t\tfor m, c in model_cfgs:\n\t\t\t\targs.model = m\n\t\t\t\targs.checkpoint = c\n\t\t\t\tr = _try_run(args, initial_batch_size)\n\t\t\t\tif 'error' in r:\n\t\t\t\t\tcontinue\n\t\t\t\tif args.checkpoint:\n\t\t\t\t\tr['checkpoint'] = args.checkpoint\n\t\t\t\tresults.append(r)\n\t\texcept KeyboardInterrupt as e:\n\t\t\tpass\n\t\tresults = sorted(results, key=lambda x: x['top1'], reverse=True)\n\telse:\n\t\tif args.retry:\n\t\t\tresults = _try_run(args, args.batch_size)\n\t\telse:\n\t\t\tresults = validate(args)\n\tif args.results_file:\n\t\twrite_results(args.results_file, results, format=args.results_format)\n\t# output results in JSON to stdout w/ delimiter for runner script\n\tprint(f'--result\\n{json.dumps(results, indent=4)}')",
      "metadata": {
         "section_header": "main",
         "type": "python function"
      }
   },
   {
      "page_content": "def write_results(results_file, results, format='csv'):\n\twith open(results_file, mode='w') as cf:\n\t\tif format == 'json':\n\t\t\tjson.dump(results, cf, indent=4)\n\t\telse:\n\t\t\tif not isinstance(results, (list, tuple)):\n\t\t\t\tresults = [results]\n\t\t\tif not results:\n\t\t\t\treturn\n\t\t\tdw = csv.DictWriter(cf, fieldnames=results[0].keys())\n\t\t\tdw.writeheader()\n\t\t\tfor r in results:\n\t\t\t\tdw.writerow(r)\n\t\t\tcf.flush()",
      "metadata": {
         "section_header": "write_results",
         "type": "python function"
      }
   }
]